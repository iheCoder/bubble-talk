# 导演状态机技术实现方案（Segment 版）

目标：把对话课堂从“你一句我一句的答题机”升级为“访谈节目/电影片段”。

核心变化：

- **导演关注全局走向**：剧情/节奏/用户反馈/学习目标推进，而不是逐句调度。
- **角色有自己的人设与目标**：关注导演的“故事倾向”、用户的交互、自己的角色契约；优先级是：用户 > 人设 > 导演倾向。
- **按片段（Segment）拍摄**：允许主持人和经济学家等角色在一个片段里自主对谈，用户在“关键窗口”参与（像嘉宾/观众），沉浸且能学到东西。

本方案在原有 Beat（拍点）体系上做“上层抽象”：**Beat 是镜头语言的最小单元，Segment 是可控的叙事片段与互动窗口集合**。

---

## 1. 总体架构：把“学习对话”做成一台事件驱动的节目制作台

核心思路：**导演不写台词，导演只做“分镜/片段调度”**。台词与角色对谈由“演员引擎”生成；测评与标签由“测评引擎”注入。

### 1.1 关键组件

- **Session Orchestrator（会话编排器）**：事件循环，维护会话状态，调度导演/片段执行器/演员/测评。
- **Director Engine（导演引擎）**：输入 `SessionState + 用户反馈` → 输出 `SegmentPlan`（下一片段、叙事倾向、参与窗口、硬约束）。
- **Segment Runner（片段执行器）**：把 `SegmentPlan` 运行成“片段内多轮对谈”，管理窗口、超时、插话、收尾与回写。
- **Actor Engine（演员引擎）**：按 `SegmentPlan + BeatLibrary + RoleSpec` 生成多角色对谈的 Realtime 指令。
- **Assessment Engine（测评引擎）**：自适应测评、窗口内快题、ExitTicket，负责“可观测用户输出”与标签更新。
- **Knowledge/Asset Layer（知识与素材层）**：概念图谱、误解标签、情境模板、故事/漫画/图解素材。
- **Memory Layer（记忆层）**：会话短期记忆 + 用户长期学习画像 + 外部资料（可选）。
- **Realtime Voice I/O（实时语音交互）**：ASR 流式识别 + TTS 流式播放 + 插话中断（barge-in）。

---

## 2. 概念重构：导演、角色、用户分别关心什么

### 2.1 导演：Showrunner，而不是逐句调度器

导演的职责从“下一个拍点是什么”升级为“下一段节目怎么拍”：

- **全局叙事倾向（Narrative Tilt）**：这一段更偏“故事/对抗/严谨/迁移/总结/搞笑”哪一侧。
- **学习目标推进（Objective Progress）**：本段要推进哪个概念关系/边界/误解纠偏。
- **用户反馈闭环（Feedback Loop）**：根据用户参与度、输出质量、困惑/疲惫信号调整片段形态。
- **参与窗口设计（Interaction Windows）**：在哪些关键点让用户说，用户必须输出什么才算“有效参与”。

> 直觉：导演看的是“节目是否好看、好学、可收束”，而不是“用户当前心理是不是 Fog/Partial”。

### 2.2 角色：有目标、有边界、有自主对谈能力

每个角色包含三类约束：

- **人设契约（Persona Contract）**：语气、用词、立场范围、禁止行为（不装懂、不跳出角色、避免过度术语）。
- **角色目标（Role Goal）**：在片段内“想达成什么”（引导用户说、提出反例、解释机制、推动故事冲突等）。
- **对导演倾向的接受度（Director Alignment）**：愿意把叙事往导演倾向拉的程度（不是硬命令）。

优先级（片段内冲突时的选择顺序）：

1) **用户交互第一位**：用户提问/插话/纠错要先接住并给可执行回应。
2) **人设第二位**：保持角色风格一致，避免每句都像“系统提示”。
3) **导演倾向第三位**：尽量把剧情往导演希望的方向走，但允许被用户互动打断或重定向。

### 2.3 Segment：片段是“可控的自治范围”

Segment 由三部分构成：

- **Segment Goal**：这一段要达成的教学/叙事目标（可衡量）。
- **Autonomy Budget**：允许演员在片段内自主对谈的“长度/轮次/自由度”预算。
- **Interaction Windows**：用户参与窗口列表（时间点/触发条件/必须输出的形式）。

Segment 的意义：**让“角色自己聊一段”成为可控而非失控**。

### 2.4 Interaction Window：把用户从“答题机”变成“嘉宾/观众”

窗口的目标不是“插一句”，而是让用户在关键点做一次可观测输出，从而：

- 让角色对谈“有观众参与感”（节目感）
- 让学习推进“有证据”（可测/可纠偏/可收束）

常见窗口类型（可与测评引擎联动）：

- `choice`：二选一/三选一 + 1 句理由（适合 Debate/分歧）
- `teach_back`：用一句话复述核心关系（适合 DeepDive/Wrap）
- `example`：给出一个自己的例子（适合迁移与巩固）
- `boundary`：说出“什么时候不适用/需要补充什么假设”（适合纠偏与严谨）
- `transfer`：换一个场景再套同一结构（适合 Montage）

### 2.5 剧本（Script）：每个泡泡的“剧情先验”，导演以它为起点而非终点

这里的 Script 更接近影视/综艺意义上的“剧本”，而不是零散的教学片段集合。它回答的是：

- 这集节目讲什么？（Logline/主题）
- 冲突怎么起？（Cold Open）
- 解释怎么落？（澄清/纠偏）
- 观众怎么参与？（互动窗口）
- 最后怎么收？（Wrap/Exit）

剧本带来的价值：**开局就“像节目”，推进就“像剧情”**，让用户自然地以观众/嘉宾身份参与，而不是被迫当答题机。

但剧本不是强约束：**用户参与会让剧情偏航**。导演不是“执行剧本的人”，而是“实时改写剧本的人”，改写依据包括：

- 故事发展：已经发生了什么、当前冲突是否成立、哪些误解被激活了
- 用户反馈：说了什么、沉默/插话、困惑/疲惫、是否强追问
- 学习目标：核心关系/边界/迁移是否已经出现“有效证据”

导演对剧本的运行态度可以用三种模式描述：

- **FOLLOW（跟剧本）**：互动与预期一致，按 scene 卡推进，节目感最强
- **ADAPT（沿主题改写）**：保留主题/冲突/结论，但重写 scene 的组织方式与窗口时机
- **REWRITE（即时重写）**：用户需求压倒预设，剧本只保留“主题+风格”，其余改写

重要约束：**剧本不绑定角色人设**。

- 剧本只写“角色槽位”与“场景任务”（谁负责抛冲突、谁负责澄清、谁负责控节奏、谁负责收束）。
- 角色的人设、语言风格、禁忌、边界来自独立的 `RoleSpec`（可视为“角色圣经”），以免不同泡泡的剧本重复、漂移、互相冲突。

---

## 3. 关键抽象与运行信息

这是技术方案，但不意味着必须把所有信息都落成硬结构/JSON。我的建议是：

- **对外（产品体验）要像剧本**：用文字卡片把“节目怎么拍”说清楚
- **对内（工程实现）要可控**：只把“必须校验/必须回放/必须统计”的关键字段结构化

下面给出的 JSON 示例更像“字段备忘录”，用于帮助工程对齐，并不是唯一形态。

### 3.1 Bubble / Entry（泡泡入口）

> 泡泡不是“概念名”，是“情境入口”，但必须能映射到概念骨架。

```json
{
  "entry_id": "econ_offer_weekend_worthit",
  "domain": "economics",
  "title": "周末加班值不值？",
  "hook": "你以为赚了800，其实可能亏了更贵的东西。",
  "script_id": "script_econ_offer_weekend_v1",
  "primary_concept_id": "econ_opportunity_cost",
  "secondary_concepts": ["econ_time_preference"],
  "scenario_id": "scn_weekend_tradeoff",
  "difficulty_hint": 2
}
```

### 3.2 Concept Pack（概念课包骨架）

导演与测评与演员都依赖它，避免“随口胡说”。

```json
{
  "concept_id": "econ_opportunity_cost",
  "core_relation": "机会成本=放弃的最好替代选择的价值（不是支出本身）",
  "misconceptions": [
    {"tag": "M1_cost_equals_money_spent", "splitter_prompt": "把机会成本误认为花出去的钱"},
    {"tag": "M2_sunk_cost_confusion", "splitter_prompt": "混淆沉没成本与机会成本"}
  ],
  "boundaries": ["当替代选择不明确时，用'最好替代'定义会变模糊，需要补充假设"],
  "story_assets": ["asset_story_offer", "asset_story_queue"],
  "transfer_targets": ["product_scope_tradeoff", "policy_budget_tradeoff"]
}
```

### 3.3 Script（泡泡剧本）

> 剧本建议提前由大模型生成（可人工审核/打版本）。它应当更像“分场景的节目脚本”，而不是一堆教学卡片。

剧本推荐内容（偏文字表达，不强求结构化到 JSON）：

- **Logline**：一句话主题（这一集到底讲什么）
- **Theme**：冲突轴/价值观（“赚到的钱 ≠ 赚到的收益”）
- **Scene Cards**：按顺序排列的场景卡（每张卡描述：开场冲突、推进点、收束点）
- **Audience Windows**：每个场景的观众参与窗口（主持人问你怎么看/让你选边/让你复述）
- **Improvisation Rules**：偏航时怎么处理（先接住用户，再回主题；回不去就转场）

关键点：剧本只写“角色槽位”和“场景任务”，不写角色人设。角色的人设由 `RoleSpec` 统一管理（避免重复与漂移）。

#### 3.3.1 剧本示例（节选，偏“访谈节目”）

片名：《周末加班值不值？》

Logline：你以为周末多赚 800，其实你可能放弃了更值钱的东西。

角色槽位：

- 主持人：抛冲突、控节奏、把用户拉进窗口
- 经济学家：澄清概念、纠偏误解、给出可迁移的判断框架

Scene 1：Cold Open（开场冲突，制造好奇）

- 画面：主持人抛出“赚 800”这个诱饵
- 台词走向（纲要，不是逐字稿）：
  - 主持人：用一句夸张幽默的开场把问题抛出来（“你周末赚了 800？恭喜你……可能亏惨了。”）
  - 经济学家：先承认直觉合理，再埋“换个问法”的钩子（“你放弃了什么？”）
- 观众窗口（主持人发问）：你觉得“赚了”还是“亏了”？选一个，并说一句理由

Scene 2：Debate（对抗澄清，把误解打出来）

- 画面：主持人与经济学家围绕“赚了/亏了”互相抬杠
- 台词走向（纲要）：
  - 主持人：把用户常见误解说出来（“钱到手了不就赚了吗？”）
  - 经济学家：不直接否定，改用“最好替代选择”逐步逼近概念
  - 主持人：用非专业表达把概念翻译成人话，再把问题抛回给用户
- 观众窗口（关键窗口）：用一句话复述：机会成本是什么（必须包含“最好替代选择”，且不要把它说成“花出去的钱”）

Scene 3：Wrap（收束与迁移）

- 画面：主持人做“节目总结”，经济学家给“迁移模板”
- 观众窗口（可选）：给一个自己的例子（把同一结构迁移到另一个选择）

> 这份剧本是“默认轨道”。运行时导演可以把 Scene 2 拆成多个 Segment、把 Wrap 提前、或插入 MiniGame；是否这么做取决于用户反馈与状态。

### 3.4 RoleSpec（角色规格）

> 角色是“镜头语言载体”。导演只选角与倾向；角色负责把倾向“演出来”。

这里额外强调两点：

1) **人设独立于剧本**：剧本只决定“这一段要发生什么”，不决定“角色是谁/怎么说话”。角色人设统一维护在 `RoleSpec`（角色圣经），跨泡泡复用。
2) **人设尽量固定**：运行时只切换 `stance/task/constraints`（要做什么、怎么做、不能做什么），避免每轮重写 persona 导致漂移。

```json
{
  "role_id": "economist",
  "persona": {
    "style": "严谨但不端着，用例子驱动推理",
    "taboos": ["不要编造数据", "不要引入未在ConceptPack出现的新概念名"],
    "allowed_stances": ["Explain", "Challenge", "Socratic", "Summarize"]
  },
  "role_goal_templates": [
    {"segment_type": "DeepDive", "goal": "把核心关系说清楚，并逼出一次用户复述"},
    {"segment_type": "Debate", "goal": "提出反例/边界条件，引导用户做选择"}
  ],
  "director_alignment": 0.6,
  "user_priority": 1.0
}
```

### 3.5 SessionState（会话状态）

这是导演引擎的“全局画板”，强调“节目走向”而不是逐句心智状态。

```json
{
  "session_id": "...",
  "entry_id": "...",
  "main_objective": "能用机会成本解释取舍，并区分它与支出/沉没成本",
  "stage": "SHOOT",
  "act": 2,
  "script": {
    "script_id": "script_econ_offer_weekend_v1",
    "scene_id": "scene_02_debate",
    "scene_cursor": 2,
    "alignment_mode": "FOLLOW",
    "alignment_score": 0.72
  },
  "narrative_tilt": {
    "mode": "INTERVIEW",
    "tone": "LIGHT",
    "teaching_style": "SOCRATIC"
  },
  "progress": {
    "mastery_estimate": 0.42,
    "misconception_tags": ["M1_cost_equals_money_spent"],
    "last_effective_output_at_sec": 68
  },
  "segment": {
    "segment_id": "seg_0007",
    "segment_type": "Debate",
    "started_at_sec": 83,
    "interaction_window_cursor": 1
  },
  "question_stack": [
    {"q": "那是不是所有选择都能算出机会成本？", "urgency": 2, "link_to_objective": 2}
  ],
  "signals": {
    "turns": 9,
    "avg_latency_ms": 950,
    "interruptions": 2,
    "user_output_quality": 0.55,
    "engagement_proxy": {"attention": 0.7, "boredom": 0.1},
    "confusion_proxy": 0.6
  }
}
```

### 3.6 SegmentPlan（导演决策输出）

导演引擎只产出 `SegmentPlan`：片段类型 + 参与窗口 + 预算 + 约束。

```json
{
  "segment_id": "seg_0008",
  "segment_type": "DeepDive",
  "script_cue": {
    "script_id": "script_econ_offer_weekend_v1",
    "scene_id": "scene_02_debate",
    "cue": "先让主持人抛出'加班赚800是不是赚了'的冲突，再由经济学家澄清机会成本不是支出"
  },
  "narrative_tilt": {"mode": "INTERVIEW", "tone": "LIGHT", "teaching_style": "SOCRATIC"},
  "roles": [
    {"role_id": "host", "stance": "Guide"},
    {"role_id": "economist", "stance": "Explain"}
  ],
  "segment_goal": {
    "teaching": "把机会成本与'花出去的钱'区分开",
    "user_must_do": {"type": "teach_back", "prompt": "用一句话说清：机会成本到底是什么（不要提“花出去的钱”）"}
  },
  "autonomy_budget": {"max_sec": 55, "max_turns": 6},
  "interaction_windows": [
    {
      "window_id": "w1",
      "trigger": "AFTER_SETUP",
      "max_wait_sec": 12,
      "user_must_do": {"type": "choice", "prompt": "你更认同A还是B？选一个并说一句理由"}
    },
    {
      "window_id": "w2",
      "trigger": "BEFORE_WRAP",
      "max_wait_sec": 15,
      "user_must_do": {"type": "teach_back", "prompt": "请你复述：机会成本 = ？（带上“最好替代选择”）"}
    }
  ],
  "guardrails": {
    "max_total_output_sec": 90,
    "must_reference": ["core_relation", "misconception_tags"],
    "disallow_new_roles": true
  },
  "fallback": {
    "on_fatigue": {"segment_type": "MiniGame"},
    "on_off_topic": {"segment_type": "HookBack"},
    "on_user_stop": {"segment_type": "ExitTicket"}
  },
  "notes": "让主持人开场制造冲突，再让经济学家解释；用户在两个窗口参与"
}
```

---

## 4. 执行循环：事件驱动的“导演-片段-观众”机制

### 4.1 高层事件流

1. 用户点击泡泡 → `ENTER`
2. `LOAD_SCRIPT`：加载该泡泡的 `Script`（预生成剧本），作为“默认剧情轨道”
3. `DIAGNOSE`：测评引擎出 2–4 题 → 更新掌握度/误解标签/初始叙事倾向
4. `SHOOT`：循环执行 Segment（每段是一段节目片段）
5. 用户请求结束 or 达到收束条件 → `EXIT`：ExitTicket
6. 写回用户模型 → `UPDATE` → 回首页泡泡更新

### 4.2 Segment 循环（关键）

每个片段一次性规划、片段内自治运行：

- 收集输入：`UserUtterance + SessionState + LastSegmentsSummary`
- 调用导演：`DirectorEngine(...) -> SegmentPlan`
- Segment Runner 运行片段：
  - 编译片段指令：`SegmentPlan + BeatLibrary + RoleSpec -> Realtime Instructions`
  - 允许角色自主对谈（不必每句都回导演）
  - 在 Interaction Window 处暂停/提问，让用户参与
  - 处理 barge-in：用户插话随时打断 → 进入“片段内纠偏/转场”策略
- 更新状态：segment 游标、掌握度、误解标签、有效输出时间、question_stack 等

> 关键：导演只在“片段边界”或“重大打断”时介入；片段内由 Segment Runner 负责微观控制与护栏。

---

## 5. 导演引擎实现：规则硬约束 + LLM 软决策的混合策略（面向 Segment）

导演不能纯 LLM（太漂），也不能纯规则（太死）。推荐 **Hybrid Policy**，但决策单位从 Beat 升级为 Segment。

### 5.1 三层决策框架

#### Layer A：硬约束校验（Deterministic Guardrails）

在调用 LLM 或接受其输出前，先做硬约束（面向片段）：

- `segment.autonomy_budget.max_sec` 上限：避免角色聊嗨失控
- `progress.last_effective_output_at_sec` 距离太久：强制安排“窗口逼输出”
- 用户说“结束/别讲了” ：必须转 `ExitTicket` 或最短 Wrap
- `roles[].role_id` 必须 ∈ `state.available_roles`（泡泡固定角色集合，不能发明新角色）
- `segment_type` 必须 ∈ SegmentLibrary（未知则回退到 `DeepDive` 或 `MicroCheck`）
- 每段必须至少包含 1 个可观测 `user_must_do`（否则视为无效片段）

#### Layer B：用户反馈与意图识别（LLM + Heuristic）

用户反馈不是“导演唯一轴”，而是片段选择的重要信号之一：

- **Heuristic** 粗判：是否追问 why/how、是否 off-topic、是否沉默/短句、是否频繁插话
- **LLM Router** 精判输出：`intent`（Clarify/Challenge/Expand/Meta/Stop/OffTopic）+ `confidence`
- 结果写入 `signals` 与 `fallback` 触发器

#### Layer C：片段选择（Segment Strategy Mapping）

导演选择的是“节目片段形态”，典型 SegmentType（示例）：

- `ColdOpen`：用 hook 迅速建立冲突与好奇
- `Setup`：定义问题边界与角色立场
- `DeepDive`：解释核心关系与机制链（含 1 次窗口复述）
- `Debate`：主持人与专家对抗/反例，逼用户选边
- `Montage`：多场景迁移蒙太奇（快速切换）
- `MiniGame`：游戏化测评/轻量互动降负荷
- `Wrap`：一口气总结 + 迁移建议 + ExitTicket
- `HookBack`：跑题后温柔拉回主线

此外，若引入 `Script`，Layer C 还需要额外做一层“是否按剧本走”的判断：

- 计算 `alignment_score`：用户输入与当前 scene 的预期目标/窗口是否一致
- 选择 `alignment_mode`：`FOLLOW|ADAPT|REWRITE`
  - `FOLLOW`：尽量复用剧本 scene 的窗口与推进点
  - `ADAPT`：保留剧本的主题与冲突，重写本段 segment 的组织方式（窗口/话术/节奏）
  - `REWRITE`：用户需求压倒剧本，进入即时重写（剧本只保留风格与最终目标）

### 5.2 SegmentPicker：候选集 + 选择（可双阶段）

推荐把 Layer C 拆成两步：

1) **CandidateBuilder（规则）**：根据硬约束 + 反馈信号 + 进度产出 `segment_candidates`（通常 2–5 个）
2) **SegmentPicker（LLM）**：从候选集中选 `segment_type`、安排窗口、设置 autonomy budget 与叙事倾向

效果优先版本可用“双阶段”：

- **Planner**：生成 2–3 个候选 `SegmentPlan`（不同片段形态/不同倾向）
- **Critic/Judge**：检查护栏、成本、目标推进、用户参与质量，选最优

---

## 6. 片段内微观控制：Beat 仍然重要，但位置下沉

Beat 仍是“镜头语言最小单元”，但它由 Segment Runner/Actor Engine 在片段内组织，不要求每个 Beat 都回导演。

建议保留 `docs/附件 A：导演状态机规则集（Director State Machine Rule Set）.md` 的 BeatLibrary，并增加一层“Segment → Beat 组合模板”：

- `DeepDive`：RevealBeat → LensShiftBeat → MicroCheck（短 Check）→ FeynmanBeat（可选）
- `Debate`：TwistBeat → Deepen（对抗/反例）→ UserChoiceWindow → CheckBeat → Cooldown/ExitTicket
- `Montage`：TransferSwap × N → MicroCheck（短 Check）

片段内的硬约束（由 Segment Runner 执行）：

- 超时强制 Wrap（避免角色自嗨）
- 用户插话优先处理（必要时直接提前进入窗口或改走 HookBack）
- 每段结束前必须完成 `segment_goal.user_must_do`

## 7. 选角与片段编译：先定片段，再选角，再编译成“可演的指令”

### 7.1 RolePicker（选角）要面向 Segment，而不是面向单句

先规则过滤（硬约束），再 LLM 细选（软偏好）：

- 过滤：不允许的 stance/action 直接剔除
- 偏好：逼输出与控节奏 → 主持人优先；纠错与机制 → 专家优先
- 片段一致性：尽量减少“镜头跳切”，除非片段模板需要对抗

### 7.2 SegmentPromptCompiler：把片段编译成 Realtime 指令

演员引擎的目标不是“写台词”，而是**生成可控的片段内多角色对谈指令**：

- 每个 role 一段 Role Definition（人设契约，尽量固定，不随片段改写）
- 片段 Outline（最多 4–6 个 bullet，说明要聊的推进点）
- Window 脚本（窗口触发时必须问用户的那一句话）
- Constraints（时长、避免新概念、必须引用核心关系/误解标签）

当用户在片段内提出“与导演走向冲突”的输入时，角色的处理原则：

- **先接住用户**：用本角色的人设风格快速解答/澄清（允许“非专业表达”但不允许事实胡编）
- **再完成导演意图**：把用户回答自然地引回本段的窗口输出（例如用幽默转场后提问/让用户选边）
- **最后才追求剧本复原**：如果能顺便回到剧本 scene 的推进点最好；回不去就由导演切 `ADAPT/REWRITE`

推荐三条路线（从稳到强）：

- 路线 A：纯模板（最稳）——按 `segment_type` 预设 Outline + Window 文案，只填 slot
- 路线 B：模板 + LLM 改写（推荐）——模板钉死约束，LLM 只负责更自然更像人
- 路线 C：全 LLM 编译（上限最高）——必须 JSON schema + Guardrails 自动修复

------

## 8. 测评与题目注入：自适应测评 + 窗口内“微测评”

### 8.1 题型模板库（结构化生成）

- Misconception Splitter：每个选项对应一个误解标签
- Boundary Probe：适用/不适用条件
- Transfer Swap：换场景同结构
- Feynman Rubric：句式脚手架 + 评分要点（关系词/条件/结果）

### 8.2 自适应策略（V1 简化）

- 初始：1 道极简单题（建立信心）
- 若正确且解释强：跳到迁移题
- 若正确但解释弱：出 Splitter/Boundary
- 若错误但推理丰富：出更清晰的 Check + LensShift
- 若错误且命中误解：TwistBeat + Splitter

> 关键是把“误解标签”当一等公民，题目是“打标签的探针”。

------

## 9. 分叉问题栈（QuestionStack）：让用户自由，但主线不散

### 9.1 入栈策略

Branch 判定后入栈，记录：

- `question`
- `stage_at_ask`
- `urgency`（用户是否强烈要求立刻答）
- `link_to_objective`（与主目标相关度）

### 9.2 回收策略（片尾彩蛋/Act III）

- 每次只回收 1 个
- 若相关度高：当作 Deepen
- 若相关度低：生成新泡泡入口（Entry）并放首页推荐

------

## 10. 实时语音插话（barge-in）：节目感的关键工程点

如果你要“用户可实时插话”，必须做 **流式 ASR + 可中断 TTS**。

### 10.1 技术机制

- TTS 播放时并行开 ASR 监听
- 监听到用户语音能量 + 识别置信度达阈值 → **立即暂停 TTS**
- 将“被打断的演员台词”标记为 `interrupted=true`，写入对话历史
- 导演引擎接收 `UserUtterance`，并把 `interruptions++` 作为信号输入（代表用户参与感很强或不耐烦）

### 10.2 被打断后的片段策略（优先由 Segment Runner 执行）

- 若用户 Clarify：立刻进入最近的窗口或触发一次短 `MicroCheck`，然后回到当前片段的推进点继续；必要时提前 `Wrap`
- 若用户 Branch：入栈 + 片段内给“先答/稍后答”的选择（避免主线散）
- 若用户 Off-topic：轻接住后走 `HookBack`，把话题拉回本段目标

------

## 11. 掌握度与“有效输出质量”更新：导演的燃料（用于选片段，而不是选台词）

### 11.1 输出质量评分（轻量可实现）

把用户输出映射到 0–1：

- 是否包含关系词（因果/权衡）
- 是否提到条件/边界（L4）
- 是否能举出自洽例子
- 是否能区分相近概念（误解消除）

这可以先用规则 + LLM 判分结合：

- 规则：关键词/结构（because/therefore/if-then）
- LLM：给出 rubric 打分与一句解释（不展示给用户）

### 11.2 Mastery 更新（V1）

一个可用的更新式：

- `mastery += α * (quiz_signal + output_quality_signal + transfer_signal) - β * misconception_pressure`
- `misconception_pressure` 在 Twist/Boundary 命中纠正后下降

------

## 12. 概念图谱与跨领域扩展：经济学只是一个 domain

为了不被领域锁死，导演状态机层面只认：

- `domain`
- `primary_concept_id`
- `core_relation`
- `misconceptions`
- `boundaries`
- `transfer_targets`

经济学/编程/历史只是 Concept Pack 的不同实例。
泡泡“更有趣”的生成，本质是 `Scenario -> Concept` 的映射与改写（title/hook），不会影响导演的控制逻辑。

------

## 13. 推荐的实现形态：双模型编排（强烈建议）

### 13.1 为什么要双模型

- 导演模型：小输出、强结构、稳定路由（便宜且可控）
- 演员模型：负责语言、故事、角色风格（更“像大片”）

这能把“可控性”与“表现力”分开，避免一个模型既要管结构又要演戏导致漂移。

------

## 14. 一段“可落地”的伪代码级执行（简化示意）

```text
while session.active:
  event = wait(user_input or tts_finished or timeout)
  update_signals(event)

  if state.stage == DIAGNOSE:
     q = assessment.next_question(state)
     ask(q)
     continue

  if need_new_segment(event, state):
     seg_plan = director(state, last_segments_summary, user_input)
     seg_plan = apply_guardrails(seg_plan, state)
     seg_plan.roles = role_picker(seg_plan, state.available_roles, role_specs, recent_role_memory)
     seg_instructions = segment_prompt_compiler(seg_plan, beat_library, concept_pack, role_specs)
     segment_runner.start(seg_plan, seg_instructions)

  segment_runner.handle(event)  # 片段内多角色对谈、窗口暂停、插话、超时Wrap
  state = reducer(state, segment_runner.snapshot(), assessment.snapshot(), event)
```xxxxxxxxxx while session.active:  event = wait(user_input or tts_finished or timeout)  update_signals(event)  if state.stage == DIAGNOSE:     q = assessment.next_question(state)     ask(q)     continue  if need_new_segment(event, state):     seg_plan = director(state, last_segments_summary, user_input)     seg_plan = apply_guardrails(seg_plan, state)     seg_plan.roles = role_picker(seg_plan, state.available_roles, role_specs, recent_role_memory)     seg_instructions = segment_prompt_compiler(seg_plan, beat_library, concept_pack, role_specs)     segment_runner.start(seg_plan, seg_instructions)  segment_runner.handle(event)  # 片段内多角色对谈、窗口暂停、插话、超时Wrap  state = reducer(state, segment_runner.snapshot(), assessment.snapshot(), event)```xxxxxxxxxx while session.active:  event = wait(user_input or tts_finished or timeout)  update_signals(event)  if state.stage == DIAGNOSE:     q = assessment.next_question(state)     ask(q)     continue  if need_new_segment(event, state):     seg_plan = director(state, last_segments_summary, user_input)     seg_plan = apply_guardrails(seg_plan, state)     seg_plan.roles = role_picker(seg_plan, state.available_roles, role_specs, recent_role_memory)     seg_instructions = segment_prompt_compiler(seg_plan, beat_library, concept_pack, role_specs)     segment_runner.start(seg_plan, seg_instructions)  segment_runner.handle(event)  # 片段内多角色对谈、窗口暂停、插话、超时Wrap  state = reducer(state, segment_runner.snapshot(), assessment.snapshot(), event)texttext
```