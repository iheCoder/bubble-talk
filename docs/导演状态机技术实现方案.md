# 导演状态机技术实现方案



## 1. 总体架构：把“学习对话”做成一台事件驱动的电影剪辑机

核心思路：**导演不直接“聊天”，导演只做“调度决策”**。实际台词由“演员模型”生成。这样对话才稳定、可控、可扩展。

#### 1.1 关键组件

- **Session Orchestrator（会话编排器）**：事件循环，维护 session 状态，调用导演、演员、题目生成器。
- **Director Engine（导演引擎）**：输入状态 + 用户话语 → 输出 `DirectorPlan`（下一拍点、角色、输出动作、节奏、栈操作）。
- **Actor Engine（演员引擎）**：按 `DirectorPlan` + Beat 指令卡生成下一段台词（文本/语音脚本）。
- **Assessment Engine（测评引擎）**：自适应测评、拍点中的快题、ExitTicket。
- **Knowledge/Asset Layer（知识与素材层）**：概念图谱、情境模板、误解标签、故事/漫画/图解素材。
- **Memory Layer（记忆层）**：会话短期记忆 + 用户长期学习画像 + 外部资料（可选）。
- **Realtime Voice I/O（实时语音交互）**：ASR 流式识别 + TTS 流式播放 + 插话中断（barge-in）。



## 2. 核心对象与数据结构：一切都结构化，导演只“填表”

### 2.1 Bubble / Entry（泡泡入口）

> 泡泡不是“概念名”，是“情境入口”，但必须能映射到概念骨架。

```json
{
  "entry_id": "econ_offer_weekend_worthit",
  "domain": "economics",
  "title": "周末加班值不值？",
  "hook": "你以为赚了800，其实可能亏了更贵的东西。",
  "primary_concept_id": "econ_opportunity_cost",
  "secondary_concepts": ["econ_time_preference"],
  "scenario_id": "scn_weekend_tradeoff",
  "difficulty_hint": 2
}
```

### 2.2 Concept Pack（概念课包骨架）

导演与题目生成必须依赖它，避免“随口胡说”。

```json
{
  "concept_id": "econ_opportunity_cost",
  "core_relation": "机会成本=放弃的最好替代选择的价值（不是支出本身）",
  "misconceptions": [
    {"tag": "M1_cost_equals_money_spent", "splitter_prompt": "把机会成本误认为花出去的钱"},
    {"tag": "M2_sunk_cost_confusion", "splitter_prompt": "混淆沉没成本与机会成本"}
  ],
  "boundaries": ["当替代选择不明确时，用'最好替代'定义会变模糊，需要补充假设"],
  "story_assets": ["asset_story_offer", "asset_story_queue"],
  "transfer_targets": ["product_scope_tradeoff", "policy_budget_tradeoff"]
}
```

### 2.3 SessionState（会话状态）

这是导演引擎的“输入画板”。

```json
{
  "session_id": "...",
  "entry_id": "...",
  "main_objective": "用机会成本的镜头解释取舍，并能区分它与支出/沉没成本",
  "act": 2,
  "stage": "SEMINAR",
  "beat": "TwistBeat",
  "mastery_estimate": 0.42,
  "misconception_tags": ["M1_cost_equals_money_spent"],
  "output_clock_sec": 83,
  "tension_level": 3,
  "cognitive_load": 2,
  "pacing_mode": "NORMAL",
  "question_stack": [
    {"q": "那是不是所有选择都能算出机会成本？", "urgency": 2, "at_beat": "RevealBeat"}
  ],
  "signals": {
    "turns": 9,
    "avg_latency_ms": 950,
    "interruptions": 2,
    "user_output_quality": 0.55,
    "affect_proxy": {"confusion": 0.6, "boredom": 0.1, "frustration": 0.2}
  }
}
```

### 2.4 DirectorPlan（导演决策输出）

导演引擎只产出这个，确保系统可控。

```json
{
  "user_mind_state": ["Partial", "Verify"],
  "intent": "Deepen",
  "next_beat": "LensShiftBeat",
  "next_role": "Expert",
  "output_action": "OneSentenceRecap",
  "talk_burst_limit_sec": 35,
  "tension_goal": "maintain",
  "load_goal": "maintain",
  "stack_action": {"type": "keep"},
  "notes": "换视角解释，稳定核心关系，并立刻让用户复述校准"
}
```

------

## 3. 执行循环：事件驱动的“导演-演员-观众”回合制

### 3.1 高层事件流

1. 用户点击泡泡 → `ENTER`
2. `DIAGNOSE`：测评引擎出 2–4 题 → 更新 `mastery_estimate/misconceptions`
3. `SEMINAR`：循环执行拍点
4. 用户请求结束 or 达到收束条件 → `EXIT`：ExitTicket
5. 写回用户模型 → `UPDATE` → 回首页泡泡更新

### 3.2 Seminar 回合（关键）

每回合处理一个“拍点”：

- 收集输入：`UserUtterance + LastTurnsSummary + SessionState`
- 调用导演：`DirectorEngine(...) -> DirectorPlan`
- 根据 DirectorPlan 选择 Beat 指令卡，构造给演员的“台词任务书”
- 调用演员生成台词（文本/语音脚本）
- 播放（TTS）或展示文本
- 等待用户插话（含 barge-in）并记录信号
- 更新状态：OutputClock、MindState、栈、误解标签、掌握度

------

## 4. 导演引擎实现：规则硬约束 + LLM 软决策的混合策略

导演不能纯 LLM（太漂），也不能纯规则（太死）。推荐 **Hybrid Policy**：

### 4.1 三层决策框架

#### Layer A：硬约束校验（Deterministic Guardrails）

在调用 LLM 或接受其输出前，先做硬约束：

- `output_clock_sec >= 90` → next_beat 必须 ∈ {CheckBeat, FeynmanBeat, MiniGameBeat, TransferSwap, ExitTicket}
- 用户说“懂了/结束” → next_beat 必须是 ExitTicket 或 Transfer 检验
- Branch → 默认入栈 + BranchTeaserBeat（除非与当前误解强相关，才可降为 Deepen）

#### Layer B：意图/心智状态识别（LLM + Heuristic）

- **Heuristic** 先粗判：关键词、是否问 why/how、是否提新概念名、是否请求换风格、是否大量“嗯/懂了”
- **LLM Router** 精判输出：`UserMindState` + `Intent` + `Confidence`
- 最终用加权融合：heuristic 兜底，LLM 负责细腻判断

#### Layer C：拍点选择（Beat Scheduler）

Beat 选择用 **“候选集 + 打分”**：

1. 按当前 Act/Stage 生成候选 Beat 集合（比如 Act II 候选 Twist/LensShift/Feynman/MiniGame…）
2. 对每个 Beat 计算 `score = wTruth*gain + wFeel*curve + wPace*fit - penalties`
3. 取最高分 Beat，并附上 `OutputAction`

> 这一步你后续可进化成 bandit / RL，但 V1 用线性打分就能跑。

### 4.2 评分特征（可直接实现）

- `gain`（理解增益预估）：是否能命中当前 misconception、是否能推进到 L4/L5 输出层级
- `curve`（情绪曲线）：Fog 时给 Hook/Reveal，Illusion 时给 Check/Twist，Fatigue 时给 MiniGame
- `fit`（节奏契合）：当前 Tension/CognitiveLoad 的目标变化
- `penalties`：连续同类 beat、连续长讲、分叉栈过深

------

## 5. 演员引擎实现：把“指令卡”当作 DSL

你已经有 Beat 指令卡，技术上建议把它做成“模板化 DSL”，演员模型只负责把模板填满并保证风格。

### 5.1 给演员的输入构造

- 只给**当前主目标 + 当前拍点 + 必须引导的输出动作**
- 给必要的概念骨架（core_relation + 当前误解标签 + 边界点）
- 给少量用户背景与偏好（已确认过的）
- 给 TalkBurstLimit

### 5.2 输出格式约束

演员输出建议固定结构，便于 TTS 与插话：

- `speech_text`（可朗读文本，≤ TalkBurstLimit）
- `user_prompt`（明确让用户做的动作）
- `fallbacks`（用户不配合时的替代问法 1–2 条）

------

## 6. 测评与题目注入：自适应测评 + 拍点内“微测评”

### 6.1 题型模板库（结构化生成）

- Misconception Splitter：每个选项对应一个误解标签
- Boundary Probe：适用/不适用条件
- Transfer Swap：换场景同结构
- Feynman Rubric：句式脚手架 + 评分要点（关系词/条件/结果）

### 6.2 自适应策略（V1 简化）

- 初始：1 道极简单题（建立信心）
- 若正确且解释强：跳到迁移题
- 若正确但解释弱：出 Splitter/Boundary
- 若错误但推理丰富：出更清晰的 Check + LensShift
- 若错误且命中误解：TwistBeat + Splitter

> 关键是把“误解标签”当一等公民，题目是“打标签的探针”。

------

## 7. 分叉问题栈（QuestionStack）：让用户自由，但主线不散

### 7.1 入栈策略

Branch 判定后入栈，记录：

- `question`
- `stage_at_ask`
- `urgency`（用户是否强烈要求立刻答）
- `link_to_objective`（与主目标相关度）

### 7.2 回收策略（片尾彩蛋/Act III）

- 每次只回收 1 个
- 若相关度高：当作 Deepen
- 若相关度低：生成新泡泡入口（Entry）并放首页推荐

------

## 8. 实时语音插话（barge-in）：电影感的关键工程点

如果你要“用户可实时插话”，必须做 **流式 ASR + 可中断 TTS**。

### 8.1 技术机制

- TTS 播放时并行开 ASR 监听
- 监听到用户语音能量 + 识别置信度达阈值 → **立即暂停 TTS**
- 将“被打断的演员台词”标记为 `interrupted=true`，写入对话历史
- 导演引擎接收 `UserUtterance`，并把 `interruptions++` 作为信号输入（代表用户参与感很强或不耐烦）

### 8.2 被打断后的导演策略

- 若用户 Clarify：立刻 Check 或短 Clarify，再回到上一拍点继续（必要时用 Cooldown 收束）
- 若用户 Branch：入栈 + BranchTeaser（给选择）
- 若用户 Off-topic：轻接住后用 Hook 拉回

------

## 9. 掌握度与“有效输出质量”更新：导演状态机的燃料

### 9.1 输出质量评分（轻量可实现）

把用户输出映射到 0–1：

- 是否包含关系词（因果/权衡）
- 是否提到条件/边界（L4）
- 是否能举出自洽例子
- 是否能区分相近概念（误解消除）

这可以先用规则 + LLM 判分结合：

- 规则：关键词/结构（because/therefore/if-then）
- LLM：给出 rubric 打分与一句解释（不展示给用户）

### 9.2 Mastery 更新（V1）

一个可用的更新式：

- `mastery += α * (quiz_signal + output_quality_signal + transfer_signal) - β * misconception_pressure`
- `misconception_pressure` 在 Twist/Boundary 命中纠正后下降

------

## 10. 概念图谱与跨领域扩展：经济学只是一个 domain

为了不被领域锁死，导演状态机层面只认：

- `domain`
- `primary_concept_id`
- `core_relation`
- `misconceptions`
- `boundaries`
- `transfer_targets`

经济学/编程/历史只是 Concept Pack 的不同实例。
泡泡“更有趣”的生成，本质是 `Scenario -> Concept` 的映射与改写（title/hook），不会影响导演的控制逻辑。

------

## 11. 推荐的实现形态：双模型编排（强烈建议）

### 11.1 为什么要双模型

- 导演模型：小输出、强结构、稳定路由（便宜且可控）
- 演员模型：负责语言、故事、角色风格（更“像大片”）

这能把“可控性”与“表现力”分开，避免一个模型既要管结构又要演戏导致漂移。

------

## 12. 一段“可落地”的伪代码级执行（简化示意）

```text
while session.active:
  event = wait(user_input or tts_finished or timeout)

  update_signals(event)

  if state.stage == DIAGNOSE:
     q = assessment.next_question(state)
     ask(q)
     continue

  director_plan = director(state, last_turns, user_input)
  director_plan = apply_guardrails(director_plan, state)

  beat_card = BeatLibrary[director_plan.next_beat]
  actor_prompt = build_actor_prompt(state, director_plan, beat_card, concept_pack)

  actor_line = actor(actor_prompt)
  speak_or_show(actor_line)

  state = reducer(state, director_plan, actor_line, event)
```

