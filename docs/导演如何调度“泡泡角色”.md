# BubbleTalk 技术方案：导演如何调度“泡泡角色”（Role Orchestration）

> 本文只讲一件事：**导演（Director）如何在“角色人设固定”的前提下，调度角色发言、调度教学动作、调度工具，并把这一切变成工程上可实现、可调试、可扩展的系统。**
> 角色示例：某个泡泡只有 **「经济学家 Economist」+「主持人 Host」**，导演不能新增/替换角色，只能在这两者之间切换，并在各自允许的“姿态/能力”范围内编排。

## 0. 目标与边界

### 0.1 目标（第一阶段要达成）

1. **角色固定**：每个泡泡的角色集合是固定配置（不能临时发明 Coach/Challenger 这种“新人物”）。
2. **调度可控**：导演每一轮输出结构化计划 `DirectorPlan`，可校验、可回放、可解释。
3. **教学不漂移**：必须能持续推动“用户输出”（复述/选择/举例/边界/费曼/迁移），防止只聊不学。
4. **工具可控**：题目/图解/评分等工具不允许“角色随便调用”，必须经过导演/编排器批准。
5. **调试友好**：每轮都能显示：导演输入（摘要）、导演计划、为什么选这个角色/姿态、是否触发护栏。

### 0.2 非目标（第一阶段先不做或可简化）

- 多角色同时发言（第一阶段建议**每轮只允许一个主讲角色**）
- 复杂个性化推荐、长期记忆、跨泡泡剧情联动
- 语音/实时插话（可以第二阶段再加）

## 1. 统一术语（避免黑话）

### 1.1 教学动作 TeachingAction（每轮导演要选的“动作类型”）

这些不是“电影装饰词”，而是**教学阶段标签**：

- **ENGAGE**：拉回注意力/建立兴趣（用用户熟悉场景引入）
- **DEFINE**：给“一句话核心定义”（最短正确模型）
- **CHECK**：立刻验证是否听懂（复述/判断/选择）
- **CORRECT**：纠错，专打典型误解（反例/拆错因）
- **REFRAME**：换角度再解释（同概念不同视角）
- **FEYNMAN**：让用户讲给别人（暴露漏洞并固化）
- **TRANSFER**：迁移到新场景（证明能用）
- **WRAPUP**：三句收束（总结 + 下一步）

> 对应之前的词：
> Hook≈ENGAGE，Reveal≈DEFINE，Check≈CHECK，Twist≈CORRECT，LensShift≈REFRAME，Feynman≈FEYNMAN，Montage≈TRANSFER(快迁移)，ExitTicket≈TRANSFER+WRAPUP（离场验票）

### 1.2 教学姿态 TeachingStance（角色在这一轮采取的表达方式）

同一个角色并不等于固定一种语气，它可以在允许范围内切换“姿态”：

- **Explain**：结构化讲清楚
- **Socratic**：提问引导用户输出
- **Challenge**：质疑/反例/戳误区
- **Summarize**：收束复盘
- **Encourage**：降压、鼓励、降低羞耻成本

### 1.3 工具 Tool（道具）

- **Quiz**：选择/判断/填空（本阶段只做选择/判断足够）
- **DiagramCard**：对比表、因果链、流程图（第一阶段可用“结构化卡片渲染”，不必真生成图片）
- **RubricScore**：对用户输出质量打分（第一阶段可规则，后续可 LLM）

## 2. 核心原则：角色固定，但“职责可编排”

### 2.1 角色=世界观人物（固定）

每个泡泡定义一个 `RoleSet`：

```
{
  "bubble_id": "econ_opportunity_cost",
  "roles": ["Economist", "Host"]
}
```

### 2.2 角色能力=接口（可配置）

导演不能改变人设，但可以在能力边界内调度。

`role_library.json` 示例：

```
{
  "Economist": {
    "persona": "严谨、机制链、概念边界清楚",
    "allowed_stances": ["Explain", "Challenge"],
    "allowed_actions": ["DEFINE", "CORRECT", "REFRAME"],
    "can_propose_tools": ["DiagramCard", "Quiz:concept"]
  },
  "Host": {
    "persona": "控节奏、善于把话挂到用户生活、引导用户回答",
    "allowed_stances": ["Encourage", "Socratic", "Summarize"],
    "allowed_actions": ["ENGAGE", "CHECK", "FEYNMAN", "TRANSFER", "WRAPUP"],
    "can_propose_tools": ["Quiz:all", "RubricScore"]
  }
}
```

> 这一步解决你的关键约束：
> **角色固定，但导演仍然能“调度职责”**，因为职责通过 `allowed_actions + allowed_stances` 显式化。

## 3. 导演输入是什么（DirectorInput）

导演不是读全文聊天记录，而是读“监控面板”式的结构化摘要。
这样可控、稳定、可测试。

### 3.1 DirectorInput 数据结构（建议）

```
{
  "session": {
    "bubble_id": "econ_opportunity_cost",
    "main_objective": "理解机会成本并能迁移应用",
    "stage": "MID", 
    "turn_index": 7
  },
  "user_state": {
    "Fog": 0.10,
    "Illusion": 0.55,
    "Partial": 0.25,
    "Verify": 0.10
  },
  "learning": {
    "mastery": 0.42,
    "misconceptions": ["M1_money_spent"],
    "last_output_quality": 0.35
  },
  "rhythm": {
    "output_clock_sec": 80,
    "cognitive_load": 3,
    "tension": 2,
    "fatigue_risk": 0.2
  },
  "role_memory": {
    "Economist": { "last_action": "DEFINE", "last_stance": "Explain" },
    "Host": { "last_action": "CHECK", "last_stance": "Socratic" }
  },
  "recent_summary": {
    "last_user_message": "我懂了，机会成本就是我花出去的钱。",
    "last_system_action": "CHECK",
    "last_quiz_result": "none"
  },
  "branch": {
    "stack_depth": 0,
    "pending_questions": []
  }
}
```

### 3.2 这些字段从哪来？

- `user_state`：启发式 +（可选）Router LLM 分类输出
- `learning`：答题结果 + 输出质量规则评分
- `rhythm`：客户端时序 + 输出时钟 OutputClock
- `role_memory`：每轮计划写回 state
- `recent_summary`：编排器自动生成（不要塞全对话）

## 4. 导演输出是什么（DirectorPlan）

导演输出**只是一份可执行计划**，不包含台词。

```
{
  "teaching_action": "CORRECT",
  "target_role": "Economist",
  "stance": "Challenge",
  "user_must_do": {
    "type": "choice",
    "goal": "识别误解 M1_money_spent"
  },
  "tool_plan": [
    { "type": "Quiz", "subtype": "misconception_splitter", "params": { "tag": "M1_money_spent" } }
  ],
  "constraints": {
    "talk_burst_sec": 25,
    "must_reference": ["core_relation"],
    "avoid": ["长篇推导", "新增无关概念"]
  },
  "guardrail_notes": ["output_clock逼近阈值，必须触发用户选择题输出"],
  "debug_reason": "用户自信但错误；Economist允许CORRECT+Challenge；Host不擅长严谨纠错"
}
```

## 5. 导演到底在“做什么”：一轮决策的可实现流水线

这一节是你最关心的“看得懂、知道怎么下手”。

### 5.1 流水线总览

每轮只做 6 步：

1. **判状态**：用户现在更像 Fog/Illusion/Partial/Verify/Expand/Fatigue 哪一个
2. **选教学动作**：这轮最该做 ENGAGE/DEFINE/CHECK/CORRECT/REFRAME/FEYNMAN/TRANSFER/WRAPUP 哪个
3. **选角色**：在泡泡固定角色集合中选谁做这件事
4. **选姿态**：该角色用 Explain / Socratic / Challenge / Summarize / Encourage 哪种姿态
5. **决定是否用工具**：出题/卡片/评分是否必要（以及类型）
6. **护栏修正**：节奏、输出、分叉深度、结束请求等硬约束校验

> 重点：导演不是“生成 prompt”，导演是**选择动作 + 角色 + 工具 + 输出要求**。

## 6. 角色调度算法（可落地实现）

### 6.1 Step A：教学动作选择（ActionSelector）

输入：DirectorInput
输出：`teaching_action`

建议做成“候选 + 打分”而不是纯 if-else，便于调参。

#### 6.1.1 候选集合规则

- 若用户说“结束/懂了”：候选只有 `TRANSFER` 或 `WRAPUP`
- 若 `output_clock_sec >= 90`：候选必须包含 `CHECK/FEYNMAN/TRANSFER`（逼输出）
- 若 Illusion 高：候选优先 `CORRECT`
- 若 Fog 高：候选优先 `ENGAGE/DEFINE/CHECK`
- 若 Verify 高：候选优先 `REFRAME/FEYNMAN`（边界与自述）
- 若 Fatigue 高：候选优先 `ENGAGE/WRAPUP`（降负荷收束）

#### 6.1.2 简化打分（第一阶段足够）

- `output_urgency = clamp(output_clock_sec/90, 0..1)`
- `illusion = user_state["Illusion"]`
- `fog = user_state["Fog"]`
- `verify = user_state["Verify"]`
- `fatigue = rhythm.fatigue_risk`

例：

- CORRECT 得分 = `2*illusion + 1*output_urgency - 1*fatigue`
- DEFINE 得分 = `2*fog - 0.5*illusion`
- CHECK 得分 = `1*output_urgency + 0.5*fog + 0.5*illusion`
- TRANSFER 得分 = `1*(mastery>0.6) + 1*end_request`

选最高分。

### 6.2 Step B：角色选择（RoleSelector）

输入：`teaching_action` + 角色能力矩阵
输出：`target_role`

规则很直观：

1. 过滤：只保留 `allowed_actions` 包含该 action 的角色
2. 打分：

- 若该角色上轮刚讲过同类 action，扣分（防重复疲劳）
- 若该 action 需要“严谨纠错”，偏向 Economist
- 若该 action 需要“逼输出/控节奏”，偏向 Host

示例：

- action=CORRECT：Host 不允许（或能力弱）→ 自动选 Economist
- action=TRANSFER：Economist 不允许（或弱）→ 自动选 Host

### 6.3 Step C：姿态选择（StanceSelector）

输入：`target_role` + `user_state` + action
输出：`stance`

例：

- action=CORRECT 且 illusion 高 → stance=Challenge
- action=CHECK/FEYNMAN → stance=Socratic
- fatigue 高 → stance=Encourage 或 Summarize

并且必须在 `role.allowed_stances` 内。

### 6.4 Step D：工具计划（ToolPlanner）

这里回答你的“工具应该谁调用”的纠结。

#### 6.4.1 原则：角色可以“提议”，导演/编排器“批准并执行”

因为工具涉及成本与节奏控制，必须中心化。

#### 6.4.2 规划规则（第一阶段）

- action=CHECK：默认 `Quiz:light`（判断题/单选）
- action=CORRECT 且存在误解 tag：`Quiz:misconception_splitter`
- action=REFRAME：`DiagramCard:compare`（对比表）
- action=FEYNMAN：`RubricScore`（规则评分即可）
- action=TRANSFER：`Quiz:transfer`（换场景题）
- fatigue 高：减少工具，用 `WRAPUP + 简短 exit`

> 第一阶段 DiagramCard 可以不生成图片：
> 用结构化卡片 JSON，前端渲染表格/流程即可。

### 6.5 Step E：护栏（Guardrails）

护栏是“导演计划的编译器报错/修正器”。

必做规则：

1. `output_clock_sec >= 90` → `user_must_do` 必须是 Choice/Recap/Feynman/Transfer 之一
2. 用户请求结束 → 必须走 `TRANSFER`（短也行）+ `WRAPUP`
3. 不允许角色执行其 `allowed_actions` 之外的 action
4. talk_burst_sec 受 pacing 限制（例如 20/30/45 秒）
5. 分叉（Branch）如果存在：必须 Host 先“入栈并承诺回收”，避免主线散

## 7. Prompt 为什么不由大模型“再生成”（工程解释版）

Prompt 不应“生成”，应“编译”。原因是可控性与可测试性。

### 7.1 编译式 PromptBuilder（推荐）

Prompt = `RoleCard(固定)` + `ActionCard(模板)` + `StateSummary(短)` + `ToolResults(若有)` + `UserUtterance`

- RoleCard：该角色的人设、禁忌、表达风格（固定文本）
- ActionCard：本轮教学动作的模板指令（固定模板）
- StateSummary：主目标 + 误解标签 + 必须让用户做的动作（短摘要）
- ToolResults：题目/卡片内容（结构化插入）

这样：

- 你可以单测：action=CORRECT 是否一定带 splitter
- 你可以回放：为什么这轮选 Economist 而不是 Host
- 你可以调参：illusion 权重上调会不会更多触发 CORRECT

### 7.2 “灵活性”放在哪里？

放在 **角色生成台词** 的温度/措辞，而不是 prompt 结构本身。
结构必须稳定，否则你教育闭环会松。

## 8. 角色是否能自己调用工具？（最终定案）

### 8.1 推荐机制（稳定版本）

- Actor 输出里允许 `tool_suggestion`（提议）
- Orchestrator 决定是否执行（批准/拒绝/替换）

Actor 输出示例：

```
{
  "speech_text": "我们来用一个小题确认下你理解的点。",
  "tool_suggestion": { "type": "Quiz", "subtype": "misconception_splitter", "tag": "M1_money_spent" }
}
```

Orchestrator：

- 如果与 DirectorPlan 的 tool_plan 一致 → 执行
- 如果不一致 → 以 DirectorPlan 为准（或记录对比用于评估）

> 这样既保留“角色临场聪明”，又不把系统控制权交出去。

## 9. 从开始到结束：导演如何演化整场会话（Stage FSM）

为了避免“每轮都像随机聊天”，导演还要维护宏观阶段：

- **START**：刚进入泡泡（目标：ENGAGE/DEFINE）
- **BUILD**：建立核心模型并检查（DEFINE→CHECK）
- **FIX**：专打误解并重建（CORRECT/REFRAME）
- **SOLIDIFY**：费曼输出固化（FEYNMAN）
- **APPLY**：迁移应用（TRANSFER）
- **END**：收束（WRAPUP）

阶段迁移条件（第一阶段写死即可）：

- BUILD→FIX：检测到误解标签且输出质量低
- FIX→SOLIDIFY：误解压低 + 输出质量上升
- SOLIDIFY→APPLY：完成一次费曼合格
- APPLY→END：迁移题完成（或用户强退也要短迁移）

## 10. 端到端示例（你一看就知道导演在干嘛）

**场景**：机会成本泡泡（Economist + Host）
用户说：“我懂了，机会成本就是我花出去的钱。”

### 10.1 DirectorInput（关键字段）

- Illusion=0.6
- misconception=M1_money_spent
- output_clock=80s

### 10.2 DirectorPlan（输出）

```
{
  "teaching_action": "CORRECT",
  "target_role": "Economist",
  "stance": "Challenge",
  "user_must_do": { "type": "choice", "goal": "区分机会成本与支出" },
  "tool_plan": [
    { "type": "Quiz", "subtype": "misconception_splitter", "params": { "tag": "M1_money_spent" } }
  ],
  "constraints": { "talk_burst_sec": 20 }
}
```

### 10.3 Orchestrator 执行 ToolPlan（先生成题）

返回一个单选题：
A. 花出去的钱
B. 放弃的最好选择
C. 感觉亏了
D. 时间很贵

### 10.4 PromptBuilder 编译给 Economist（非生成）

- 你是 Economist
- 这轮 action=CORRECT，stance=Challenge
- 用 20 秒以内指出误解并让用户做题
- 必须引用 core_relation
- 不要扩展新概念

### 10.5 Economist 生成台词（ActorReply）

> “你把‘支出’当成机会成本了。
> 机会成本不是花了多少，而是你为了这个选择放弃的最好替代。
> 先选题：上面哪一项才是机会成本？”

这轮完成：纠错 + 用户输出 + 主线未散。

