# BubbleTalk 第一阶段技术实现方案（导演状态机为核心｜Vue + Go｜可直接开工）

> 第一阶段目标：把“电影式对话学习”的 **导演状态机（Director State Machine）** 做扎实，跑通“主线不散 + 插话可控 + 逼出有效输出 + 必须迁移检验”的闭环。
> 其他模块（泡泡、素材、题库、推荐、图解）都允许 **固定 / mock / 极简**。

## 0. 第一阶段范围（Scope）

### 0.1 必须做（MVP-1）

1. **固定泡泡列表**（10 个以内，写死或 JSON 配置）
2. **会话编排器 Session Orchestrator**（事件驱动，维护 SessionState）
3. **导演状态机 DirectorEngine（核心）**
    - 心智状态识别（启发式 + 可选 LLM Router）
    - 插话分类（Clarify/Deepen/Branch/Meta/Off-topic）
    - Beat 选择（候选 + 打分 + 硬约束）
    - 角色选择（Host/Expert/Peer/Challenger/Coach）
    - 输出动作强制（Output Ladder + OutputClock）
4. **演员生成 ActorEngine（先用同一个 LLM 或同一供应商的另一个模型）**
    - 严格按 Beat 指令卡产出：台词 + 用户动作指令 + fallback
5. **题目与测评极简**（mock 也行）
    - DIAGNOSE：固定 2 题
    - EXIT：固定 1 题迁移 + 1 句解释
6. **前端 Vue**：两页
    - Home：泡泡列表/云（简单实现即可）
    - Session：对话区 + 选择题组件 + 分叉问题栈侧栏

### 0.2 暂缓（可不做 / mock）

- 推荐系统（先固定泡泡顺序）
- 图解/漫画生成（先用静态图片或不做）
- 语音（先纯文本；barge-in 第二阶段再上）
- 长期记忆/复习计划（先写到 session 内即可）
- 知识图谱/检索（先用 concept pack 的固定骨架）

## 1. 技术总览：用“事件循环 + 可回放状态机”拍电影

### 1.1 后端核心形态

**Go 服务 = 会话事件处理器 + 状态机决策器**

- `SessionState`：这场“电影”的拍摄现场（主目标、幕、拍点、张力、认知负荷、分叉栈…）
- `Event`：用户输入、答题、系统输出、节奏超时等
- `Reducer`：纯函数归约 `State + Event -> NewState`（可回放、易调试）
- `DirectorEngine`：读 State，产出 `DirectorPlan`（下一拍点、角色、必须让用户做什么）
- `ActorEngine`：执行 DirectorPlan，生成下一句“台词”（以及可能的题目）

> 第一阶段的关键：把 DirectorPlan 做成强约束 JSON，并且所有输出都经过 Guardrail 校验。

## 2. 目录结构（建议直接照抄开仓库）

### 2.1 Go 服务端（monorepo 也行）

```
server/
  cmd/
    bubbletalk/
      main.go
  internal/
    api/                // HTTP handlers + DTO
    session/            // orchestrator + reducer + store
    director/           // director engine + scoring + guardrails
    actor/              // actor engine + beat prompt builder
    assessment/         // diagnose/exit + quiz templates (mock)
    domain/             // fixed bubbles + concept packs (json/yaml)
    llm/                // LLM client interface + implementations
    prompt/             // prompt templates (director/router/actor)
    model/              // core structs: SessionState, Turn, Event, Plan
    util/               // json, time, id, logging helpers
  configs/
    bubbles.json
    concepts_econ.json
    concepts_prog.json
    beat_library.json
```

### 2.2 Vue 前端

```
web/
  src/
    pages/
      Home.vue
      Session.vue
    components/
      BubbleList.vue
      ChatPane.vue
      MessageBubble.vue
      QuizCard.vue
      BranchStack.vue
      DebugPlan.vue        // 可选：显示 DirectorPlan（开发期很有用）
    stores/
      session.ts
    api/
      client.ts
      session.ts
    router/
      index.ts
```

## 3. 核心数据结构（第一阶段最小但足够）

### 3.1 Bubble（固定入口）

```
configs/bubbles.json
[
  {
    "entry_id": "econ_weekend_overtime",
    "domain": "economics",
    "title": "周末加班到底值不值？",
    "hook": "你以为赚了800，可能亏了更贵的东西。",
    "primary_concept_id": "econ_opportunity_cost"
  },
  {
    "entry_id": "prog_cache_miss",
    "domain": "programming",
    "title": "为什么缓存命中率高，P99 还是爆？",
    "hook": "你以为是缓存，其实是队列和抖动。",
    "primary_concept_id": "prog_tail_latency"
  }
]
```

### 3.2 ConceptPack（骨架，防胡编）

`configs/concepts_econ.json`（示例）

```
{
  "econ_opportunity_cost": {
    "core_relation": "机会成本=放弃的最好替代选择的价值（不是支出本身）",
    "misconceptions": [
      {"tag": "M1_money_spent", "desc": "把机会成本当成花出去的钱"},
      {"tag": "M2_sunk_cost", "desc": "混淆沉没成本与机会成本"}
    ],
    "boundaries": [
      "当替代选项不明确时，需要补充‘最好替代’的假设或比较标准"
    ],
    "transfer_targets": [
      "产品砍功能的取舍",
      "团队资源分配",
      "个人 offer 选择"
    ]
  }
}
```

### 3.3 SessionState（导演引擎输入）

```
type SessionState struct {
  SessionID string
  EntryID   string
  Domain    string

  MainObjective string // 一句话
  Act           int    // 1..3
  Beat          string // e.g. "TwistBeat"
  PacingMode    string // FAST/NORMAL/DEEP

  MasteryEstimate float64 // 0..1
  MisconceptionTags []string

  OutputClockSec int
  LastOutputAt   time.Time

  TensionLevel  int // 0..5
  CognitiveLoad int // 0..5

  QuestionStack []BranchQuestion

  Signals SignalsSnapshot

  // 简化：第一阶段把对话历史也放 session 内（后续可外置）
  Turns []Turn
}
```

### 3.4 DirectorPlan（导演输出强约束）

```
type DirectorPlan struct {
  UserMindState []string // Fog/Illusion/Partial/Aha/Verify/Expand/Fatigue
  Intent        string   // Clarify/Deepen/Branch/Meta/Off-topic

  NextBeat   string
  NextRole   string
  OutputAction string // Choice/Recap/Example/Boundary/Feynman/Transfer

  TalkBurstLimitSec int

  TensionGoal string // raise/keep/lower
  LoadGoal    string // raise/keep/lower

  StackAction StackAction // keep/push/pop

  Notes string
}
```

## 4. API 设计（足够简单，能跑通）

### 4.1 Bubble 列表

- `GET /api/bubbles` → 返回 bubbles.json

### 4.2 创建会话

- `POST /api/sessions`

```
{ "entry_id": "econ_weekend_overtime" }
```

返回：

```
{
  "session_id": "S_...",
  "state": { ... },
  "diagnose": {
    "questions": [ ... ]   // 固定 2 题即可
  }
}
```

### 4.3 提交事件（用户输入/答题）

- `POST /api/sessions/{id}/events`

```
{
  "type": "user_message",
  "text": "我感觉机会成本就是我加班赚到的钱？"
}
```

返回：

```
{
  "assistant": {
    "text": "...",
    "need_user_action": { "type": "recap", "prompt": "用一句话复述..." },
    "quiz": null
  },
  "debug": { "director_plan": { ... } }
}
```

> 第一阶段建议把 `debug.director_plan` 保留（开发期太关键）。上线再关。

## 5. 会话编排器实现（Session Orchestrator）

会话编排器是整个系统的“调度中心”，负责把用户输入、导演决策、演员生成、状态更新这些环节串成一个闭环。可以把它想象成一场拍摄的“现场助理导演”：

- 它接收用户的每一句话或操作事件；
- 把这些事件交给导演状态机（DirectorEngine）去判断剧情走向；
- 再把导演的计划交给演员引擎（ActorEngine）去生成台词；
- 最后更新会话状态并返回结果给前端。

### 5.1 模块组成

1. **事件接收器（Event Handler）**
   负责接收前端发来的事件（用户发言、答题、点击分支等），并将其封装成统一的 `Event` 对象。
2. **状态管理器（Session Manager）**
   负责读取和保存当前会话的状态（SessionState），包括当前幕、节奏、误解标签、输出时钟等。
3. **导演接口（DirectorEngine）**
   根据当前状态和用户输入，生成下一步的导演计划（DirectorPlan），决定剧情走向、角色、输出动作等。
4. **演员接口（ActorEngine）**
   根据导演计划生成具体的系统回复（台词、问题、提示等）。
5. **信号与监控模块（Signals）**
   记录用户的响应时间、输入长度、情绪信号等，用于节奏控制和心智状态判断。
6. **存储层（Store）**
   负责持久化 SessionState，第一阶段可以用内存实现，后续可替换为 Redis 或数据库。

### 5.2 核心循环（同步执行）

每当用户发来一条消息或答题事件时，编排器执行以下步骤：

1. **读取当前会话状态**：从 Store 中取出该 session 的最新状态。
2. **记录用户输入**：将用户的发言或操作追加到对话历史中。
3. **更新信号与时钟**：计算用户响应时间、更新 OutputClock（距离上次输出的时间）。
4. **调用导演引擎**：把当前状态和用户输入交给 DirectorEngine，生成新的导演计划（DirectorPlan）。
5. **执行安全校验**：用 Guardrail 模块检查导演计划是否违反硬约束（如输出超时、分支过深等），必要时修正。
6. **调用演员引擎**：根据导演计划生成系统回复（台词、问题、提示等）。
7. **更新会话状态**：将新的导演计划、演员输出、信号等写回 SessionState。
8. **保存状态**：通过 Store 持久化更新后的状态。
9. **返回结果**：把系统回复（以及可选的调试信息）返回给前端。

### 5.3 Store（第一阶段先内存）

```
type SessionStore interface {
  Get(ctx context.Context, id string) (*SessionState, error)
  Save(ctx context.Context, s *SessionState) error
}
```

实现：

- `InMemoryStore`：使用 map + RWMutex 存储所有会话状态，适合开发调试阶段。
- 未来可替换为 Redis 或数据库实现，不影响核心逻辑（接口隔离保证可扩展性）。

## 6. 第一阶段的“导演状态机”总体设计与实现

导演状态机（Director State Machine）是整个系统的核心调度者，它的职责是根据当前会话状态、用户输入、学习目标和节奏信号，决定下一步该由谁说、说什么、以什么方式推进剧情。可以把它理解为一位“电影导演”，负责在每一帧中安排演员、镜头、节奏和情绪。

### 6.1 顶层结构与模块关系

导演状态机由五个主要模块组成，它们协同工作形成一个完整的决策闭环：

1. **Engine（引擎入口）**：对外暴露统一接口 `Decide()`，接收当前会话状态和用户事件，输出导演计划（DirectorPlan）。
2. **Heuristics（启发式识别）**：通过规则和特征分析用户输入，识别心智状态（MindState）和意图（Intent）。
3. **Router LLM（可选分类器）**：在需要更细腻判断时调用 LLM，对心智状态和意图进行补充识别。
4. **Scheduler（调度器）**：根据当前幕（Act）、心智状态、意图等生成候选拍点（Beat），并通过打分机制选择最优拍点。
5. **Guardrails（护栏系统）**：在决策后进行硬约束校验，确保输出符合节奏、安全和教学目标。

模块之间的关系如下：

- Engine 调用 Heuristics 和 Router LLM 获取用户状态；
- Scheduler 根据这些状态生成候选方案；
- Guardrails 对 Scheduler 的结果进行修正；
- 最终 Engine 输出一个结构化的 DirectorPlan，交由 ActorEngine 执行。

### 6.2 Engine 模块：导演的中枢

Engine 是导演状态机的主控模块，负责协调各子模块的调用顺序。其主要流程如下：

1. **接收输入**：从会话状态中读取用户输入、当前幕、节奏信号等。
2. **前置判断**：检测是否触发强制事件（如用户说“结束”或输出超时）。
3. **状态识别**：调用 Heuristics（或 Router LLM）识别用户心智状态与意图。
4. **生成候选拍点**：调用 Scheduler 生成候选 Beat 列表。
5. **选择最优方案**：根据打分结果选出最合适的 Beat。
6. **角色与输出动作分配**：确定由哪个角色发言、用户需要执行的输出动作。
7. **护栏修正**：调用 Guardrails 校验并修正不合规的计划。
8. **输出计划**：生成最终的 DirectorPlan，交由演员模块执行。

### 6.3 Heuristics 模块：快速识别用户状态

Heuristics 模块通过一系列规则和特征函数，对用户输入进行分析，判断其当前的认知状态和意图。
主要组成：

- **特征提取器**：分析用户输入的长度、关键词、语气、延迟等。
- **规则匹配器**：根据特征组合判断心智状态（如 Fog、Aha、Fatigue）。
- **意图分类器**：识别用户是在澄清、深入、分支还是元对话。

该模块的目标是快速、可解释地给出一个初步判断，为后续调度提供依据。

### 6.4 Router LLM 模块：智能补充识别

Router LLM 是可选模块，用于在启发式规则不够精确时提供更细腻的判断。
它接收最近几轮对话和上下文摘要，输出结构化 JSON，包括心智状态、意图和置信度。
Engine 根据置信度决定是否采用 LLM 的结果。
这样既能保持系统的可控性，又能在复杂语境下获得更准确的识别。

### 6.5 Scheduler 模块：生成与选择拍点

Scheduler 是导演状态机的“调度中心”，负责根据当前剧情阶段、用户心智状态、认知负荷、张力等信号生成候选拍点（Beat），并通过多维打分机制选出最优方案，同时分配合适的角色与输出动作。

#### 6.5.1 候选生成（Candidate Generation）

候选生成遵循“剧情阶段 + 心智状态 + 输出节奏”三层逻辑：

1. **按幕（Act）筛选基础候选集**
    - Act I（引入）：`ColdOpen`, `Hook`, `Reveal`, `Check`
    - Act II（深化）：`Twist`, `LensShift`, `Check`, `Feynman`, `MiniGame`, `BranchTeaser`
    - Act III（收束）：`Cooldown`, `Montage`, `ExitTicket`, `PostCredit`
2. **按心智状态加权扩展**
    - Fog：强化 `Hook`, `Reveal`, `Check`
    - Illusion：强化 `Check`, `Twist`
    - Partial：强化 `LensShift`, `Feynman`
    - Verify：强化 `Boundary`, `Feynman`
    - Expand：强化 `Montage`, `BranchTeaser`
    - Fatigue：强化 `MiniGame`, `Cooldown`, `ExitTicket`
3. **按节奏与输出时钟过滤**
    - 若 `OutputClockSec > 90`，仅保留输出类拍点（`Check`, `Feynman`, `Transfer`, `ExitTicket`）
    - 若 `TensionLevel < 2`，优先选能提升张力的拍点（`Hook`, `Twist`）
    - 若 `CognitiveLoad > 4`，优先选能缓和的拍点（`MiniGame`, `Cooldown`）

最终生成 3~6 个候选拍点，每个候选包含基础元信息：

```json
{
  "beat": "Twist",
  "default_role": "Challenger",
  "default_output": "Boundary",
  "expected_tension_delta": +1,
  "expected_load_delta": +1
}
```

#### 6.5.2 打分计算（Scoring）

每个候选拍点的综合得分由以下部分组成：

| 维度        | 说明                                            | 权重 |
| ----------- | ----------------------------------------------- | ---- |
| truthGain   | 当前误解修正潜力（与 MisconceptionTags 匹配度） | 0.4  |
| feelCurve   | 张力与情绪曲线匹配度（是否能维持“起承转合”）    | 0.2  |
| paceFit     | 节奏匹配度（是否符合 OutputClock、Act 节奏）    | 0.2  |
| novelty     | 与上一个拍点差异度（避免重复）                  | 0.1  |
| riskPenalty | 认知负荷过高或分支过深的惩罚项                  | -0.1 |

计算公式示例：

```
score = 0.4*truthGain + 0.2*feelCurve + 0.2*paceFit + 0.1*novelty - 0.1*riskPenalty
```

每个子项的计算逻辑：

- **truthGain**：若拍点能直接针对当前误解标签（如 M1_money_spent），+2；若能引导用户自我修正，+1。
- **feelCurve**：若当前张力低且拍点能提升张力，+1；若张力高且拍点能缓和，+1。
- **paceFit**：若 OutputClock 超时且拍点为输出类，+2；若连续两次长讲，-1。
- **novelty**：与上一个拍点不同类型，+1。
- **riskPenalty**：若认知负荷 >4 且拍点为 Deep 类，-2。

最终取得分最高的拍点作为下一步计划。

#### 6.5.3 角色与输出动作分配（Role & Output Assignment）

1. **角色分配规则**

    - `Hook`, `Reveal` → `Host` 或 `Expert`
    - `Twist`, `Boundary` → `Challenger`
    - `Check`, `Feynman` → `Coach`
    - `MiniGame`, `Cooldown` → `Peer`
    - 若心智状态为 `Fatigue`，强制降级为 `Peer` 或 `Host`（降低压迫感）

2. **输出动作分配规则**

    - 每个拍点绑定默认输出动作（如 `Check` → `Choice`, `Feynman` → `Explain`）
    - 若 `OutputClockSec > 90`，强制输出类动作（`Recap`, `Transfer`, `Boundary`）
    - 若用户连续两轮未输出，优先分配 `Recap` 或 `MiniGame` 以重启互动
    - 输出动作需遵循 Output Ladder：`Choice → Recap → Example → Boundary → Feynman → Transfer`

3. **最终计划生成**

    - 选定拍点后，生成 `DirectorPlan`：

      ```
      {
        "NextBeat": "Twist",
        "NextRole": "Challenger",
        "OutputAction": "Boundary",
        "TensionGoal": "raise",
        "LoadGoal": "keep"
      }
      ```

    - 交由 Guardrails 校验后进入 ActorEngine 执行。

通过这种明确的候选生成、量化打分与规则化分配，Scheduler 模块能在每一轮对话中精确控制剧情节奏与学习节奏，确保 BubbleTalk 的“电影感”与“学习闭环”并行推进。

### 6.6 Guardrails 模块：安全与节奏控制

Guardrails 模块是导演状态机的安全阀，确保所有决策符合教学与节奏约束。
它会检查以下内容：

- 输出节奏是否超时（OutputClock）。
- 用户是否明确表示结束。
- 分支是否正确入栈或回收。
- 发言长度是否超限。
- 主目标是否被意外修改。

Guardrails 会在发现问题时自动修正计划，保证系统稳定运行。

### 6.7 模块协作流程总结

1. 用户输入触发 Engine。
2. Engine 调用 Heuristics（或 Router LLM）识别状态。
3. Scheduler 生成候选拍点并打分。
4. Guardrails 校验并修正。
5. Engine 输出 DirectorPlan。
6. ActorEngine 根据计划生成具体台词与动作。

通过这种自顶向下的设计，导演状态机实现了从“理解用户”到“安排剧情”的完整闭环，使系统既有电影式的节奏感，又能保持教学目标的可控性。

## 7. LLM Router（可选但强烈建议）：让识别更细腻，但仍然可控

你可以先不用 Router LLM，完全靠 heuristic 跑通；但如果想更“电影感”，Router LLM 很值。

### 7.1 Router Prompt（强制 JSON 输出）

给 router 的输入：state 摘要 + 最近 4 turn + 用户新输入

要求输出 JSON（Go 里严格解析，解析失败就退回 heuristic）：

```
{
  "user_mind_state": ["Partial"],
  "intent": "Clarify",
  "confidence": 0.78,
  "rationale_short": "用户能复述但混淆了支出与机会成本"
}
```

实现要点：

- Go 里做 `json.Unmarshal`，失败则 fallback
- 对字段做白名单校验（intent 必须在枚举内）

## 8. ActorEngine：让演员“执行分镜”，不是自由发挥

ActorEngine 是导演计划（DirectorPlan）的执行者，它负责把导演的意图转化为具体的“台词”和“动作指令”，确保每一拍都符合分镜要求。第一阶段的目标是让 ActorEngine 输出结构化、可控、可渲染的内容，为后续语音和多模态扩展打下基础。

### 8.1 模块划分

ActorEngine 建议拆分为以下子模块：

1. **PromptBuilder**：根据 DirectorPlan 组装 LLM 提示词（Prompt），包括 beat 模板、角色语气、输出动作要求、talk burst 限制等。
2. **LLMInvoker**：调用底层语言模型（可与 Router 共用客户端），并带有重试、超时、token 限制等机制。
3. **ResponseParser**：解析 LLM 返回的 JSON，校验字段完整性与类型正确性，必要时进行修正或回退。
4. **FallbackGenerator**：当 LLM 输出不合规或超时，生成安全的默认台词与用户动作提示。
5. **TemplateLibrary**：存放各类 beat 模板、角色语气模板、输出动作模板（JSON 或 YAML），便于后续扩展。

### 8.2 Actor 输入构造（关键）

输入必须包含：

- MainObjective（一句话，当前学习目标）
- 当前 beat 指令卡（模板）
- 必须触发的 OutputAction（例如 recap、example、transfer）
- 当前 misconception（最多 2 个）
- talk burst limit（最大输出长度）
- domain 角色风格（经济学/编程等）
- 上下文摘要（最近 2~3 轮对话）

PromptBuilder 会将这些信息拼装成一个结构化提示，明确告诉模型“你是哪个角色、当前拍点是什么、要做什么动作、输出格式是什么”。

### 8.3 Actor 输出格式（建议 JSON）

```
{
  "speech_text": "…（<= talk burst）",
  "user_action": { "type": "recap", "prompt": "用一句话复述，必须包含因为…所以…" },
  "quiz": null,
  "fallbacks": ["如果你卡住，就用这个句式：因为____，所以____。"]
}
```

### 8.4 实现流程

1. **构造 Prompt**：由 PromptBuilder 读取 beat 模板，插入 MainObjective、OutputAction、角色语气等变量。
2. **调用 LLM**：通过 LLMInvoker 发送请求，设置温度、最大 token、超时等参数。
3. **解析与校验**：ResponseParser 解析 JSON，若字段缺失或类型错误则触发 FallbackGenerator。
4. **输出封装**：生成 `ActorReply` 对象，包含 speech_text、user_action、quiz、fallbacks。
5. **返回前端**：Go 端解析后把 `speech_text` 当 assistant 消息展示，再把 `user_action` 交给 UI 显示提示。

### 8.5 模板示例（Beat 模板片段）

```
{
  "beat": "Twist",
  "role": "Challenger",
  "style": "简洁、有挑战性",
  "prompt_template": "你是{{role}}，当前目标是{{main_objective}}。请用不超过{{talk_burst_limit}}字的方式指出用户的误区{{misconception}}，并引导他完成{{output_action}}。输出格式必须为JSON。"
}
```

通过这种模块化设计，ActorEngine 能够在第一阶段就实现“导演指令 → 演员台词”的闭环，既可控又可扩展。

## 9. Assessment（第一阶段极简实现）

### 9.1 DIAGNOSE（固定 2 题）

- Q1 极简单题（建立信心）
- Q2 splitter（误解对抗题，选项映射到 tag）

题目可以直接写在 ConceptPack 里或 assessment 内写死。

### 9.2 EXIT（强制）

- 迁移题：换场景同结构（简答或选择）
- 一句话解释：必须包含关系词 + 一个边界条件

### 9.3 输出质量（第一阶段先粗糙）

先用规则判断：

- 是否包含因果词（因为/所以/如果）
- 是否提到边界（当…时/除非/前提）
  满足则 output_quality=0.7，否则 0.3
  （后续再上 rubric LLM）

## 10. Vue 前端实现细节（够用且好改）

### 10.1 Home.vue

- 调 `GET /api/bubbles`
- 简单列表或泡泡云（CSS 圆形）
- 点击 entry → `POST /api/sessions` → 跳转 `/session/:id`

### 10.2 Session.vue

布局三块：

- ChatPane（左）：消息列表 + 输入框
- BranchStack（右侧栏）：显示 question_stack（可点“回收”触发事件）
- QuizCard（下方弹层或插入流）：当返回 quiz 时显示

前端发送事件：

- 用户输入：`POST /events {type:user_message, text, client_ts}`
- 答题：`POST /events {type:quiz_answer, question_id, answer, client_ts}`

> 第一阶段建议每次后端响应都带 `debug.director_plan`，你做一个 DebugPlan.vue 面板，开发效率飙升。

## 11. 分阶段开发顺序（按“能跑”优先）

1. 固定 bubbles + concept packs（JSON）
2. Go：API / sessions create / in-memory store
3. Go：SessionOrchestrator（接收 user_message，先返回固定 assistant 句子）
4. Go：DirectorEngine（先做纯 heuristic + guardrails + scheduler）
5. Go：ActorEngine（先不用 LLM，按 beat 模板拼装台词，保证结构）
6. Vue：Home + Session chat 走通
7. 接入 LLM（先 Actor，再 Router）
8. 加入 DIAGNOSE 与 EXIT（固定题）
9. BranchStack 入栈/回收（BranchTeaserBeat + PostCreditBeat）

到第 7 步，你已经能看到“电影感”；到第 9 步，你会看到“可控的自由”。

## 12. 第一阶段验收标准（工程可验收，不靠主观）

- 任意会话中：**每 90 秒必触发一次用户输出动作**（recap/choice/transfer 等）
- 用户说“懂了/结束”：系统必出 **迁移检验**（exit ticket）
- 用户 Branch：必入栈并给 BranchTeaser 二选一（除非误解强相关）
- 80% 会话能完成：Act I（Hook+Reveal+Check）→ Act II（Twist 或 LensShift）→ Act III（Transfer+Exit）

如果你愿意，我下一步可以把“第一阶段导演实现”直接落到更工程化的交付物（你甚至可以复制到代码里）：

1. **DirectorPlan / ActorReply 的 JSON Schema（含枚举与校验规则）**
2. **BeatLibrary 配置文件样例（JSON）**：每个 beat 的候选条件、默认角色、输出动作、模板槽位
3. **Go 代码骨架**：director/engine.go、scheduler.go、guardrails.go 的可编译框架（含接口）

你希望我先给哪一份？（建议先给 **Schema + BeatLibrary 配置**，因为它会把全系统的接口钉死，后面写 Go/Vue 都顺。）