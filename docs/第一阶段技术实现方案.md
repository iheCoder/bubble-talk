# BubbleTalk 第一阶段技术实现方案（导演状态机为核心｜Vue + Go｜可直接开工）

> 第一阶段目标：把“电影式对话学习”的 **导演状态机（Director State Machine）** 做扎实，跑通“主线不散 + 插话可控 + 逼出有效输出 + 必须迁移检验”的闭环。
> 其他模块（泡泡、素材、题库、推荐、图解）都允许 **固定 / mock / 极简**。

## 0. 第一阶段范围（Scope）

### 0.1 必须做（MVP-1）

1. **固定泡泡列表**（10 个以内，写死或 JSON 配置）
2. **会话编排器 Session Orchestrator**（事件驱动，维护 SessionState）
3. **导演状态机 DirectorEngine（核心）**
    - 心智状态识别（启发式 + 可选 LLM Router）
    - 插话分类（Clarify/Deepen/Branch/Meta/Off-topic）
    - Beat 选择（候选 + 打分 + 硬约束）
    - 角色选择（Host/Expert/Peer/Challenger/Coach）
    - 输出动作强制（Output Ladder + OutputClock）
4. **演员生成 ActorEngine（先用同一个 LLM 或同一供应商的另一个模型）**
    - 严格按 Beat 指令卡产出：台词 + 用户动作指令 + fallback
5. **题目与测评极简**（mock 也行）
    - DIAGNOSE：固定 2 题
    - EXIT：固定 1 题迁移 + 1 句解释
6. **前端 Vue**：两页
    - Home：泡泡列表/云（简单实现即可）
    - Session：对话区 + 选择题组件 + 分叉问题栈侧栏

### 0.2 暂缓（可不做 / mock）

- 推荐系统（先固定泡泡顺序）
- 图解/漫画生成（先用静态图片或不做）
- 语音（先纯文本；barge-in 第二阶段再上）
- 长期记忆/复习计划（先写到 session 内即可）
- 知识图谱/检索（先用 concept pack 的固定骨架）

## 1. 技术总览：用“事件循环 + 可回放状态机”拍电影

### 1.1 后端核心形态

**Go 服务 = 会话事件处理器 + 状态机决策器**

- `SessionState`：这场“电影”的拍摄现场（主目标、幕、拍点、张力、认知负荷、分叉栈…）
- `Event`：用户输入、答题、系统输出、节奏超时等
- `Reducer`：纯函数归约 `State + Event -> NewState`（可回放、易调试）
- `DirectorEngine`：读 State，产出 `DirectorPlan`（下一拍点、角色、必须让用户做什么）
- `ActorEngine`：执行 DirectorPlan，生成下一句“台词”（以及可能的题目）

> 第一阶段的关键：把 DirectorPlan 做成强约束 JSON，并且所有输出都经过 Guardrail 校验。

## 2. 目录结构（建议直接照抄开仓库）

### 2.1 Go 服务端（monorepo 也行）

```
server/
  cmd/
    bubbletalk/
      main.go
  internal/
    api/                // HTTP handlers + DTO
    session/            // orchestrator + reducer + store
    director/           // director engine + scoring + guardrails
    actor/              // actor engine + beat prompt builder
    assessment/         // diagnose/exit + quiz templates (mock)
    domain/             // fixed bubbles + concept packs (json/yaml)
    llm/                // LLM client interface + implementations
    prompt/             // prompt templates (director/router/actor)
    model/              // core structs: SessionState, Turn, Event, Plan
    util/               // json, time, id, logging helpers
  configs/
    bubbles.json
    concepts_econ.json
    concepts_prog.json
    beat_library.json
```

### 2.2 Vue 前端

```
web/
  src/
    pages/
      Home.vue
      Session.vue
    components/
      BubbleList.vue
      ChatPane.vue
      MessageBubble.vue
      QuizCard.vue
      BranchStack.vue
      DebugPlan.vue        // 可选：显示 DirectorPlan（开发期很有用）
    stores/
      session.ts
    api/
      client.ts
      session.ts
    router/
      index.ts
```

## 3. 核心数据结构（第一阶段最小但足够）

### 3.1 Bubble（固定入口）

```
configs/bubbles.json
[
  {
    "entry_id": "econ_weekend_overtime",
    "domain": "economics",
    "title": "周末加班到底值不值？",
    "hook": "你以为赚了800，可能亏了更贵的东西。",
    "primary_concept_id": "econ_opportunity_cost"
  },
  {
    "entry_id": "prog_cache_miss",
    "domain": "programming",
    "title": "为什么缓存命中率高，P99 还是爆？",
    "hook": "你以为是缓存，其实是队列和抖动。",
    "primary_concept_id": "prog_tail_latency"
  }
]
```

### 3.2 ConceptPack（骨架，防胡编）

`configs/concepts_econ.json`（示例）

```
{
  "econ_opportunity_cost": {
    "core_relation": "机会成本=放弃的最好替代选择的价值（不是支出本身）",
    "misconceptions": [
      {"tag": "M1_money_spent", "desc": "把机会成本当成花出去的钱"},
      {"tag": "M2_sunk_cost", "desc": "混淆沉没成本与机会成本"}
    ],
    "boundaries": [
      "当替代选项不明确时，需要补充‘最好替代’的假设或比较标准"
    ],
    "transfer_targets": [
      "产品砍功能的取舍",
      "团队资源分配",
      "个人 offer 选择"
    ]
  }
}
```

### 3.3 SessionState（导演引擎输入）

```
type SessionState struct {
  SessionID string
  EntryID   string
  Domain    string

  MainObjective string // 一句话
  Act           int    // 1..3
  Beat          string // e.g. "TwistBeat"
  PacingMode    string // FAST/NORMAL/DEEP

  MasteryEstimate float64 // 0..1
  MisconceptionTags []string

  OutputClockSec int
  LastOutputAt   time.Time

  TensionLevel  int // 0..5
  CognitiveLoad int // 0..5

  QuestionStack []BranchQuestion

  Signals SignalsSnapshot

  // 简化：第一阶段把对话历史也放 session 内（后续可外置）
  Turns []Turn
}
```

### 3.4 DirectorPlan（导演输出强约束）

```
type DirectorPlan struct {
  UserMindState []string // Fog/Illusion/Partial/Aha/Verify/Expand/Fatigue
  Intent        string   // Clarify/Deepen/Branch/Meta/Off-topic

  NextBeat   string
  NextRole   string
  OutputAction string // Choice/Recap/Example/Boundary/Feynman/Transfer

  TalkBurstLimitSec int

  TensionGoal string // raise/keep/lower
  LoadGoal    string // raise/keep/lower

  StackAction StackAction // keep/push/pop

  Notes string
}
```

## 4. API 设计（足够简单，能跑通）

### 4.1 Bubble 列表

- `GET /api/bubbles` → 返回 bubbles.json

### 4.2 创建会话

- `POST /api/sessions`

```
{ "entry_id": "econ_weekend_overtime" }
```

返回：

```
{
  "session_id": "S_...",
  "state": { ... },
  "diagnose": {
    "questions": [ ... ]   // 固定 2 题即可
  }
}
```

### 4.3 提交事件（用户输入/答题）

- `POST /api/sessions/{id}/events`

```
{
  "type": "user_message",
  "text": "我感觉机会成本就是我加班赚到的钱？"
}
```

返回：

```
{
  "assistant": {
    "text": "...",
    "need_user_action": { "type": "recap", "prompt": "用一句话复述..." },
    "quiz": null
  },
  "debug": { "director_plan": { ... } }
}
```

> 第一阶段建议把 `debug.director_plan` 保留（开发期太关键）。上线再关。

## 5. 会话编排器实现（Session Orchestrator）

会话编排器是整个系统的“调度中心”，负责把用户输入、导演决策、演员生成、状态更新这些环节串成一个闭环。可以把它想象成一场拍摄的“现场助理导演”：

- 它接收用户的每一句话或操作事件；
- 把这些事件交给导演状态机（DirectorEngine）去判断剧情走向；
- 再把导演的计划交给演员引擎（ActorEngine）去生成台词；
- 最后更新会话状态并返回结果给前端。

### 5.1 模块组成

1. **事件接收器（Event Handler）**
   负责接收前端发来的事件（用户发言、答题、点击分支等），并将其封装成统一的 `Event` 对象。
2. **状态管理器（Session Manager）**
   负责读取和保存当前会话的状态（SessionState），包括当前幕、节奏、误解标签、输出时钟等。
3. **导演接口（DirectorEngine）**
   根据当前状态和用户输入，生成下一步的导演计划（DirectorPlan），决定剧情走向、角色、输出动作等。
4. **演员接口（ActorEngine）**
   根据导演计划生成具体的系统回复（台词、问题、提示等）。
5. **信号与监控模块（Signals）**
   记录用户的响应时间、输入长度、情绪信号等，用于节奏控制和心智状态判断。
6. **存储层（Store）**
   负责持久化 SessionState，第一阶段可以用内存实现，后续可替换为 Redis 或数据库。

### 5.2 核心循环（同步执行）

每当用户发来一条消息或答题事件时，编排器执行以下步骤：

1. **读取当前会话状态**：从 Store 中取出该 session 的最新状态。
2. **记录用户输入**：将用户的发言或操作追加到对话历史中。
3. **更新信号与时钟**：计算用户响应时间、更新 OutputClock（距离上次输出的时间）。
4. **调用导演引擎**：把当前状态和用户输入交给 DirectorEngine，生成新的导演计划（DirectorPlan）。
5. **执行安全校验**：用 Guardrail 模块检查导演计划是否违反硬约束（如输出超时、分支过深等），必要时修正。
6. **调用演员引擎**：根据导演计划生成系统回复（台词、问题、提示等）。
7. **更新会话状态**：将新的导演计划、演员输出、信号等写回 SessionState。
8. **保存状态**：通过 Store 持久化更新后的状态。
9. **返回结果**：把系统回复（以及可选的调试信息）返回给前端。

### 5.3 Store（第一阶段先内存）

```
type SessionStore interface {
  Get(ctx context.Context, id string) (*SessionState, error)
  Save(ctx context.Context, s *SessionState) error
}
```

实现：

- `InMemoryStore`：使用 map + RWMutex 存储所有会话状态，适合开发调试阶段。
- 未来可替换为 Redis 或数据库实现，不影响核心逻辑（接口隔离保证可扩展性）。

## 6. 第一阶段的“导演状态机”怎么写到能用（重点）

导演实现建议分成 5 个文件，清晰到能直接开写：

```
internal/director/
  engine.go        // 对外入口 Decide(...)
  heuristics.go    // 规则特征与心智状态粗判
  router_llm.go    // 可选：LLM router 分类器（输出 JSON）
  scheduler.go     // 候选 beat 生成 + 打分
  guardrails.go    // 硬约束校验与修正
```

## 6.1 DirectorEngine.Decide：主函数骨架（照这个写）

伪代码（几乎可直接翻成 Go）：

1. **硬触发前置**

- 如果用户说“结束/懂了/会了” → 强制 `NextBeat = ExitTicketBeat` 或 `TransferSwap`
- 如果 `OutputClockSec >= 90` → 候选 beat 必须是输出类（Check/Feynman/MiniGame/Transfer）

1. **心智状态 + 意图识别**

- heuristic 粗判：`mind0, intent0`
- 如果启用 router LLM：拿 `mind1, intent1, conf`
    - conf 高则用 mind1/int1
    - conf 低则用 mind0/int0

1. **候选 beat 生成**

- 根据 `Act` + `mind` + `intent` 生成候选列表（比如 Fog 更偏 Hook/Reveal/Check）

1. **beat 打分选择**

- 对每个 beat 算：truthGain + feelCurve + paceFit - penalty
- 取最高分 beat

1. **角色选择**

- beat→默认角色映射（Twist→Challenger，Check→Coach/Host…）
- mind 修正：Fog 时降低挑战强度，Fatigue 时换 Peer/Host

1. **输出动作选择（Output Ladder）**

- 确保本轮带一个输出动作
- 并且尽量推动输出爬梯（至少到 Boundary）

1. **Guardrails 修正**

- 再次强校验（不合规就修 plan）

## 6.2 心智状态识别（第一阶段不用“读心”，用工程代理）

### 6.2.1 Heuristic 特征（写成函数）

输入：`UserText + last 2 turns + signals`

建议做这些特征（几小时内能写完）：

- `isShortAck`：长度 < 6 且包含 “嗯/好/懂/行”
- `hasConfusionWords`：包含 “不懂/迷糊/什么意思/所以到底”
- `hasCertaintyWords`：包含 “我懂了/会了/结束”
- `asksWhyHow`：包含 “为什么/怎么/原理”
- `introducesNewTopic`：出现明显新领域词（先用词表：宏观/通胀/CAP/一致性/缓存…）
- `latencyHigh`：avg_latency_ms 上升（前端可带时间戳）
- `answerStyle`：是否包含因果词（因为/所以/如果/那么）

### 6.2.2 MindState 粗判规则（足够可用）

- Fog：hasConfusionWords 且 introducesNewTopic 或问题发散
- Illusion：isShortAck 或 “懂了”但 answerStyle 弱
- Partial：有回答但缺因果/边界
- Aha：回答含因果 + 能举例
- Verify：频繁问边界/反例/严谨性（“是否一定…”“什么时候不成立”）
- Expand：主动联想到其他领域（“那在编程里是不是…”）
- Fatigue：latencyHigh + isShortAck 频繁 + 输出越来越短

## 6.3 插话意图分类（Intent）

第一阶段直接用 heuristic：

- Clarify：问“这词啥意思/你刚那句什么意思/能举例吗”
- Deepen：问“为什么/机制/推导/更严谨”
- Branch：明显新主题 + 不在当前 concept pack 的关键词
- Meta：问节奏/难度/换角色/换风格
- Off-topic：闲聊或与学习无关

可选升级：Router LLM 输出 JSON（下一节给模板）

## 6.4 Beat Scheduler：候选 + 打分（第一阶段就做“可解释打分”）

### 6.4.1 候选集生成（按 Act）

- Act I：ColdOpen / Hook / Reveal / Check
- Act II：Twist / LensShift / Check / Feynman / MiniGame / BranchTeaser
- Act III：Cooldown / Montage / ExitTicket / PostCredit

再按 MindState 调权重：

- Fog：Hook、Reveal、Check 加权
- Illusion：Check、Twist 加权
- Verify：LensShift、Boundary（Twist 的边界版）、Feynman 加权
- Expand：Montage（迁移蒙太奇）、BranchTeaser 加权
- Fatigue：MiniGame、Cooldown、ExitTicket（收束）加权

### 6.4.2 打分函数（写死在 Go，第一阶段够用）

对每个 beat 算一个 `score`：

- `truthGain`：
    - 当前存在 MisconceptionTags 且 beat=Twist/Check → +2
    - mastery < 0.4 且 beat=Reveal/Hook → +1
    - 输出动作能上升一层（例如推动到 Boundary/Feynman）→ +1
- `feelCurve`：
    - tension 过低（≤1）且 beat=ColdOpen/Twist → +1
    - cognitive_load 过高（≥4）且 beat=Cooldown/MiniGame → +1
- `paceFit`：
    - output_clock 超时且 beat 属于输出类 → +2（强正）
    - 连续 2 次长讲倾向（Reveal/LensShift）→ penalty
- `penalty`：
    - 与上一个 beat 相同 → -2
    - QuestionStack 深且还在扩展 → -1
    - talk_burst 超限风险（DEEP 之外还想讲长）→ -1

取最高分 beat。

## 6.5 Guardrails：硬约束修正（必须写成独立函数）

```
func ApplyGuardrails(state, plan) plan
```

规则（第一阶段必须实现）：

1. `OutputClockSec >= 90` → plan.NextBeat ∈ {Check, Feynman, MiniGame, Transfer, ExitTicket}
2. 用户包含 “结束/懂了/会了” → plan.NextBeat ∈ {ExitTicket, Transfer}
3. intent=Branch → plan.StackAction=push + NextBeat=BranchTeaser（除非与当前误解强相关，才允许 Deepen）
4. TalkBurstLimit：FAST 20 / NORMAL 35 / DEEP 45
5. 单会话单主目标：若用户 Branch，不能修改 MainObjective，只能入栈或提议下次泡泡

## 7. LLM Router（可选但强烈建议）：让识别更细腻，但仍然可控

你可以先不用 Router LLM，完全靠 heuristic 跑通；但如果想更“电影感”，Router LLM 很值。

### 7.1 Router Prompt（强制 JSON 输出）

给 router 的输入：state 摘要 + 最近 4 turn + 用户新输入

要求输出 JSON（Go 里严格解析，解析失败就退回 heuristic）：

```
{
  "user_mind_state": ["Partial"],
  "intent": "Clarify",
  "confidence": 0.78,
  "rationale_short": "用户能复述但混淆了支出与机会成本"
}
```

实现要点：

- Go 里做 `json.Unmarshal`，失败则 fallback
- 对字段做白名单校验（intent 必须在枚举内）

## 8. ActorEngine：让演员“执行分镜”，不是自由发挥

ActorEngine 是导演计划（DirectorPlan）的执行者，它负责把导演的意图转化为具体的“台词”和“动作指令”，确保每一拍都符合分镜要求。第一阶段的目标是让 ActorEngine 输出结构化、可控、可渲染的内容，为后续语音和多模态扩展打下基础。

### 8.1 模块划分

ActorEngine 建议拆分为以下子模块：

1. **PromptBuilder**：根据 DirectorPlan 组装 LLM 提示词（Prompt），包括 beat 模板、角色语气、输出动作要求、talk burst 限制等。
2. **LLMInvoker**：调用底层语言模型（可与 Router 共用客户端），并带有重试、超时、token 限制等机制。
3. **ResponseParser**：解析 LLM 返回的 JSON，校验字段完整性与类型正确性，必要时进行修正或回退。
4. **FallbackGenerator**：当 LLM 输出不合规或超时，生成安全的默认台词与用户动作提示。
5. **TemplateLibrary**：存放各类 beat 模板、角色语气模板、输出动作模板（JSON 或 YAML），便于后续扩展。

### 8.2 Actor 输入构造（关键）

输入必须包含：

- MainObjective（一句话，当前学习目标）
- 当前 beat 指令卡（模板）
- 必须触发的 OutputAction（例如 recap、example、transfer）
- 当前 misconception（最多 2 个）
- talk burst limit（最大输出长度）
- domain 角色风格（经济学/编程等）
- 上下文摘要（最近 2~3 轮对话）

PromptBuilder 会将这些信息拼装成一个结构化提示，明确告诉模型“你是哪个角色、当前拍点是什么、要做什么动作、输出格式是什么”。

### 8.3 Actor 输出格式（建议 JSON）

```
{
  "speech_text": "…（<= talk burst）",
  "user_action": { "type": "recap", "prompt": "用一句话复述，必须包含因为…所以…" },
  "quiz": null,
  "fallbacks": ["如果你卡住，就用这个句式：因为____，所以____。"]
}
```

### 8.4 实现流程

1. **构造 Prompt**：由 PromptBuilder 读取 beat 模板，插入 MainObjective、OutputAction、角色语气等变量。
2. **调用 LLM**：通过 LLMInvoker 发送请求，设置温度、最大 token、超时等参数。
3. **解析与校验**：ResponseParser 解析 JSON，若字段缺失或类型错误则触发 FallbackGenerator。
4. **输出封装**：生成 `ActorReply` 对象，包含 speech_text、user_action、quiz、fallbacks。
5. **返回前端**：Go 端解析后把 `speech_text` 当 assistant 消息展示，再把 `user_action` 交给 UI 显示提示。

### 8.5 模板示例（Beat 模板片段）

```
{
  "beat": "Twist",
  "role": "Challenger",
  "style": "简洁、有挑战性",
  "prompt_template": "你是{{role}}，当前目标是{{main_objective}}。请用不超过{{talk_burst_limit}}字的方式指出用户的误区{{misconception}}，并引导他完成{{output_action}}。输出格式必须为JSON。"
}
```

通过这种模块化设计，ActorEngine 能够在第一阶段就实现“导演指令 → 演员台词”的闭环，既可控又可扩展。

## 9. Assessment（第一阶段极简实现）

### 9.1 DIAGNOSE（固定 2 题）

- Q1 极简单题（建立信心）
- Q2 splitter（误解对抗题，选项映射到 tag）

题目可以直接写在 ConceptPack 里或 assessment 内写死。

### 9.2 EXIT（强制）

- 迁移题：换场景同结构（简答或选择）
- 一句话解释：必须包含关系词 + 一个边界条件

### 9.3 输出质量（第一阶段先粗糙）

先用规则判断：

- 是否包含因果词（因为/所以/如果）
- 是否提到边界（当…时/除非/前提）
  满足则 output_quality=0.7，否则 0.3
  （后续再上 rubric LLM）

## 10. Vue 前端实现细节（够用且好改）

### 10.1 Home.vue

- 调 `GET /api/bubbles`
- 简单列表或泡泡云（CSS 圆形）
- 点击 entry → `POST /api/sessions` → 跳转 `/session/:id`

### 10.2 Session.vue

布局三块：

- ChatPane（左）：消息列表 + 输入框
- BranchStack（右侧栏）：显示 question_stack（可点“回收”触发事件）
- QuizCard（下方弹层或插入流）：当返回 quiz 时显示

前端发送事件：

- 用户输入：`POST /events {type:user_message, text, client_ts}`
- 答题：`POST /events {type:quiz_answer, question_id, answer, client_ts}`

> 第一阶段建议每次后端响应都带 `debug.director_plan`，你做一个 DebugPlan.vue 面板，开发效率飙升。

## 11. 分阶段开发顺序（按“能跑”优先）

1. 固定 bubbles + concept packs（JSON）
2. Go：API / sessions create / in-memory store
3. Go：SessionOrchestrator（接收 user_message，先返回固定 assistant 句子）
4. Go：DirectorEngine（先做纯 heuristic + guardrails + scheduler）
5. Go：ActorEngine（先不用 LLM，按 beat 模板拼装台词，保证结构）
6. Vue：Home + Session chat 走通
7. 接入 LLM（先 Actor，再 Router）
8. 加入 DIAGNOSE 与 EXIT（固定题）
9. BranchStack 入栈/回收（BranchTeaserBeat + PostCreditBeat）

到第 7 步，你已经能看到“电影感”；到第 9 步，你会看到“可控的自由”。

## 12. 第一阶段验收标准（工程可验收，不靠主观）

- 任意会话中：**每 90 秒必触发一次用户输出动作**（recap/choice/transfer 等）
- 用户说“懂了/结束”：系统必出 **迁移检验**（exit ticket）
- 用户 Branch：必入栈并给 BranchTeaser 二选一（除非误解强相关）
- 80% 会话能完成：Act I（Hook+Reveal+Check）→ Act II（Twist 或 LensShift）→ Act III（Transfer+Exit）

如果你愿意，我下一步可以把“第一阶段导演实现”直接落到更工程化的交付物（你甚至可以复制到代码里）：

1. **DirectorPlan / ActorReply 的 JSON Schema（含枚举与校验规则）**
2. **BeatLibrary 配置文件样例（JSON）**：每个 beat 的候选条件、默认角色、输出动作、模板槽位
3. **Go 代码骨架**：director/engine.go、scheduler.go、guardrails.go 的可编译框架（含接口）

你希望我先给哪一份？（建议先给 **Schema + BeatLibrary 配置**，因为它会把全系统的接口钉死，后面写 Go/Vue 都顺。）